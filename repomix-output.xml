This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yaml
  dependabot.yaml
.tetzng/
  _README.md
  arch.md
  command.md
  pez.toml
  README.md
  todo.md
docs/
  architecture.md
  commands.md
  configuration.md
  faq.md
  getting-started.md
  install.md
src/
  cmd/
    completion.rs
    doctor.rs
    init.rs
    install.rs
    list.rs
    migrate.rs
    mod.rs
    prune.rs
    uninstall.rs
    upgrade.rs
  tests_support/
    env.rs
    mod.rs
  cli.rs
  config.rs
  git.rs
  lock_file.rs
  main.rs
  models.rs
  resolver.rs
  utils.rs
.gitignore
AGENTS.md
Cargo.toml
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/dependabot.yaml">
version: 2
updates:
  - package-ecosystem: "cargo"
    directory: "/"
    schedule:
      interval: daily
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: daily
    groups:
      github-actions:
        patterns:
          - "*"
</file>

<file path=".tetzng/_README.md">
# pez

A Modern Rust-Based Plugin Manager for fish

## Installation

Ensure you have Rust installed on your system. You can install pez using Cargo:

```sh
cargo install pez
```

## Usage

```
Usage: pez <COMMAND>

Commands:
  init       Initialize pez
  install    Install fish plugin(s)
  uninstall  Uninstall fish plugin(s)
  upgrade    Upgrade installed fish plugin(s)
  list       List installed fish plugins
  prune      Prune uninstalled plugins
  help       Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
```

### init

```fish
# Initialize pez
pez init
```

### install

```fish
# Install plugins listed in pez.toml.
pez install

# Force reinstalling plugins even if they are already installed
pez install --force

# Install a specific plugin
pez install owner/package1

# Install multiple plugins at once
pez install owner/package1 owner/package2
```

```fish
pez install
```

### uninstall

```fish
# Uninstall a single plugin
pez uninstall owner/package1

# Uninstall multiple plugins
pez uninstall owner/package1 owner/package
```

### upgrade

```fish
# Upgrade all installed plugins
pez upgrade

# Upgrade a specific plugin
pez upgrade owner/package1

# Upgrade multiple plugins at once
pez upgrade owner/package1 owner/package2
```

### list

```fish
# List all installed plugins
pez list

# List only outdated plugins
pez list --outdated
```

### prune

````fish
# Prune uninstalled plugins
pez prune

# prune uninstalled plugins
### upgrade

```fish
# Upgrade all installed plugins
pez upgrade

# Upgrade a specific plugin
pez upgrade owner/package1

# Upgrade multiple plugins at once
pez upgrade owner/package1 owner/package2
````

### list

```fish
# List all installed plugins
pez list

# List only outdated plugins
pez list --outdated
```

### prune

```fish
# Prune uninstalled plugins
pez prune

# Dry run to see what would be pruned
pez prune --dry-run
```

## Configuration

pez uses two main configuration files: `pez.toml` and `pez-lock.toml.` By default, these files are created in the fish configuration directory, but you can specify a different location using environment variables.

Configuration File Locations

The configuration files are located based on the following priority: `$PEZ_CONFIG_DIR` > `$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

### pez.toml

`pez.toml` is the primary configuration file where you define the plugins you want to manage. Below is an example structure:

```toml
[[plugins]]
repo = "owner/repo" # The plugin repository in the format <owner>/<repo>

# Add additional plugins by copying the [[plugins]] block.
```

### pez-lock.toml

`pez-lock.toml` is automatically generated and maintained by pez. It records detailed information about the installed plugins, including their source repositories and specific commit SHAs. Do not edit this file manually.

## Data Directory

pez clones plugin repositories into a designated data directory, prioritized as follows: `$PEZ_DATA_DIR` > `$__fish_user_data_dir/pez` > `$XDG_DATA_HOME/fish/pez` > `~/.local/share/fish/pez`

When you install a plugin, pez clones its repository into pez_data_dir. If the directory doesn’t exist, pez will create it. If the repository is already cloned, pez will notify you and skip cloning unless you use the --force option to re-clone it.

After cloning, if the repository contains functions, completions, conf.d, or themes directories, pez will copy the files from these directories to the corresponding fish configuration directories:

- `~/.config/fish/functions`
- `~/.config/fish/completions`
- `~/.config/fish/conf.d`
- `~/.config/fish/themes`

If a file with the same name already exists in the destination, pez will overwrite it.

The destination fish configuration directory can be overridden using the following environment variables: `$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

Additionally, `pez-lock.toml` records information about the installed packages and the files copied. It is created in the same directory as `pez.toml` and will append information if it already exists.

## License

MIT

## Author

tetzng
</file>

<file path=".tetzng/arch.md">
# install の挙動

## owner/repo 指定

```fish
pez install o1/r1
```

```toml
[[plugins]]
repo = "o1/r1"
```

デフォルトブランチの最新（HEAD）がインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると現在の最新に更新される

## owner/repo@version 指定

```fish
pez install o2/r2@v3
```

```toml
[[plugins]]
repo = "o2/r2"
version = "v3"
```

指定したバージョンがインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると指定したバージョン内での最新に更新される（例: v3.0 -> v3.1）

## owner/repo@string 指定

```fish
pez install o3/r3@develop
```

```toml
[[plugins]]
repo = "o3/r3"
version = "develop"
```

指定したバージョンがインストールされる
文字列からはbranch名とtag名の区別がつかないため、version に指定される
インストール済みであれば何もしないが、--force オプションを指定すると指定したバージョン内での最新に更新される（例: develop -> develop.1）

## owner/repo@tag:string 指定

```fish
pez install o4/r4@tag:v1.0.0
```

```toml
[[plugins]]
repo = "o4/r4"
tag = "v1.0.0"
```

指定したタグがインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると指定したタグの最新に更新される

## owner/repo@branch:string 指定

```fish
pez install o5/r5@branch:develop
```

```toml
[[plugins]]
repo = "o5/r5"
branch = "develop"
```

指定したブランチの最新がインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると指定したブランチの最新に更新される

## owner/repo@latest 指定

```fish
pez install o6/r6@latest
```

```toml
[[plugins]]
repo = "o6/r6"
version = "latest"
```

latest は特別なキーワードで、常に最新がインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると現在の最新に更新される

## owner/repo@commit:string 指定

```fish
pez install o7/r7@commit:7cfa4f2e416375140fa8721b88ef8752e7cfe78b
```

```toml
[[plugins]]
repo = "o7/r7"
commit = "7cfa4f2e416375140fa8721b88ef8752e7cfe78b"
```

指定したコミットがインストールされる
インストール済みであれば何もしないが、--force オプションを指定すると指定したコミットが最新に更新される

# pez.toml の仕様

repo, url, path のいずれかを指定する必要がある
repo, url, path は同時に複数指定できない

repo または url の場合は version, tag, branch, commit を指定できる
指定は任意でデフォルトは version = "latest" と同じ挙動になる
version, tag, branch, commit はいずれか一つだけ設定可能で複数同時に指定できない

path の場合は version, tag, branch, commit は指定できない

## repo

repo は owner/repo の形式で指定する
この形式の場合、GitHub からインストールされる （例: franciscolourenco/done -> <https://github.com/franciscolourenco/done）>
GitHub 以外のリポジトリからインストールする場合は、url か path のいずれかを指定する必要がある

## url

url は GitHub 以外のリポジトリからインストールする場合に指定する
schemeを省略した場合は https:// が補完される

## path

path は ローカルのディレクトリからインストールする場合に指定する
絶対パス、または ~/ で始まるパスを指定する必要がある
相対パスはサポートされていない

## version

versionはtagやbranchを区別しない
優先度としてはまずbranchを探し、なければtagを探す
セマンティックバージョニングであれば、指定したバージョン内での最新がインストールされる（例: v3 -> v3.1）
v1で指定していて、tagが v1.0.0, v1.2.3, v2.0.0 の場合は v1.2.3 がインストールされる
branch に v1 が存在する場合は、tag よりも branch が優先される
v1.0 や v1.2 のようにマイナーバージョンまで指定した場合は、そのバージョン内での最新がインストールされる（例: v1.2 -> v1.2.3）
v1.0.0 や v2.0.0 のようにパッチバージョンまで指定した場合は、そのバージョンがインストールされる

## tag

tag は 存在するタグを指定する
指定したタグがインストールされる

## branch

branch は 存在するブランチを指定する
指定したブランチの最新がインストールされる

## commit

commit は 存在するコミットを指定する
指定したコミットがインストールされる
コミットハッシュの先頭7文字以上であれば指定できるが、同じリポジトリ内で重複する場合はエラーになる
そのため、できるだけ完全なコミットハッシュを指定することを推奨する

# upgrade の挙動

upgrade はpez.tomlに記載されているプラグインをすべて最新に更新する
repo, urlの場合は version, tag, branch, commit の指定にしたがって更新される
いずれも指定していない場合は version = "latest" と同じ挙動になり、常に最新に更新される
path の場合は現在のローカルの状態が反映される
</file>

<file path=".tetzng/command.md">
# command

## Install

```fish
pez install # pez.toml pez-lock.toml の内容をもとにパッケージをインストールする
pez install --force # すでにインストールされている場合も強制的に再インストールする
pez install owner/package1 # package1 をインストールする
pez install owner/package1 owner/package2 # package1 と package2 をインストールする
pez install owner/package1@1.0.0 # package1 のバージョン 1.0.0 をインストールする
```

実際の処理は以下の通りです。

### `pez install` (引数なし)

- `pez.toml` と `pez-lock.toml` の内容を読み込みます。
  - `pez.toml` と `pez-lock.toml` が存在しない場合は作成します。
- `pez.toml` に指定されたパッケージをすべてインストールします。
  - `pez-lock.toml` に記載されているパッケージは指定された commit sha にチェックアウトします。
- `pez-lock.toml` にインストールしたパッケージの情報を記録します。
- すでにインストールされているが、`pez.toml` に記載されていないパッケージについては何もしません。

```rs
/// リポジトリを開き、リモートから最新の変更をフェッチ
fn fetch_latest_updates(repo: &Repository) -> Result<(), Error> {
    let mut remote = repo.find_remote("origin")?;
    let callbacks = setup_remote_callbacks();
    let mut fetch_options = setup_fetch_options(callbacks);

    remote.fetch(
        &["refs/heads/*:refs/remotes/origin/*"],
        Some(&mut fetch_options),
        None,
    )?;
    println!("Fetched latest updates from remote.");
    Ok(())
}

/// デフォルトブランチの最新コミットにチェックアウト
fn checkout_default_branch(repo: &Repository) -> Result<(), Error> {
    let remote = repo.find_remote("origin")?;
    let default_branch_ref = remote
        .default_branch()?
        .as_str()
        .ok_or_else(|| Error::from_str("Failed to get the default branch name from remote."))?
        .to_string();
    let default_branch = format!("refs/remotes/origin/{}", default_branch_ref);

    let fetch_head = repo.revparse_single(&default_branch)?;
    repo.checkout_tree(&fetch_head, None)?;
    repo.set_head_detached(fetch_head.id())?;

    println!(
        "Checked out to the latest commit of the default branch: {}",
        default_branch_ref
    );
    Ok(())
}
```
</file>

<file path=".tetzng/pez.toml">
[[plugins]]
repo = "owner/repo1"

[[plugins]]
repo = "owner/repo2"
tag = "v4"

[[plugins]]
repo = "owner/repo3"
source = "gitlab.com"

[[plugins]]
repo = "owner/repo4"
commit = "1234567890abcdef1c013c6db959ed7ae954e029"

[[plugins]]
dir = "/Users/tetzng/path/to/foo"

[[plugins]]
dir = "~/path/to/bar"
</file>

<file path=".tetzng/README.md">
# pez

A Rust-based plugin manager for fish.

## Installation

```sh
cargo install pez
```

## Usage

### init

```fish
pez init # pez.toml がなければ作成する
```

pez.toml は以下のような内容で作成される

```toml
# This file defines the plugins to be installed by pez.

# Example of a plugin:
# [[plugins]]
# repo = "owner/repo"                    # The package identifier in the format <owner>/<repo>

# Add more plugins below by copying the [[plugins]] block.
```

### install

```fish
pez install # pez.toml pez-lock.toml の内容をもとにパッケージをインストールする
pez install --force # すでにインストールされている場合も強制的に再インストールする
pez install owner/package1 # package1 をインストールする
pez install owner/package1 owner/package2 # package1 と package2 をインストールする
```

### uninstall

```fish
pez uninstall owner/package1 # package1 をアンインストールする
pez uninstall owner/package1 owner/package2 # package1 と package2 をアンインストールする
```

### upgrade

```fish
pez upgrade # lock_file にある全てのパッケージをアップグレードする
pez upgrade owner/package1 # package1 をアップグレードする
pez upgrade owner/package1 owner/package2 # package1 と package2 をアップグレードする
```

### list

```fish
pez list # インストールされているパッケージをすべて表示する
pez list --outdated # アップグレード可能なパッケージを表示する
```

### prune

```fish
pez prune # pez.toml に存在しないが、pez-lock.toml に存在しているプラグインを削除する
```

## Configuration

`pez.toml` と `pez-lock.toml` は 基本的には fish の config ディレクトリに作成されるが、環境変数で作成場所を指定することも可能です。
以下の優先順位で設定されます。
`$PEZ_CONFIG_DIR` > `$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

pez-lock.toml は プラグインを install すると作成・更新され、インストールしたプラグインの情報が記録されます。
upgrade したときは、その情報が更新されます。

pez で git clone されるルートディレクトリ（以下、pez_data_dir とする）の優先順位
`$PEZ_DATA_DIR` > `$__fish_user_data_dir/pez` > `$XDG_DATA_HOME/fish/pez` > `~/.local/share/fish/pez`

pez でインストールを実行すると、対象のパッケージのリポジトリを pez_data_dir で git clone します。
pez ディレクトリが存在しなければ作成されます。
すでに git clone されている場合は、すでに存在する旨を表示して、何もしません。
存在するディレクトリを削除して、再度 git clone する場合は、`pez install --force owner/repo` で実行してください。

clone したリポジトリの中に、functions, completions, conf.d, themes のディレクトリがあれば、
その直下のファイルをそれぞれ同じ名前の~/.config/fish/functions ~/.config/fish/completions ~/.config/fish/conf.d ~/.config/fish/themes にコピーします。
コピー先に同名のファイルがある場合は、そのファイルのコピーをスキップして、エラーメッセージを表示します。

コピー先の~/.config/fish/ の部分は環境変数によって変わります。
`$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

また、pez-lock.toml にインストールしたパッケージの情報を記録します。コピーしたファイルの情報も記録します。
pez-lock.toml は pez.toml と同じディレクトリに作成され、すでに存在する場合は追記されます。

```toml
# This file is automatically generated by pez. Do not edit it manually.
version = 1

[[plugins]]
name = "repo"
source = "https://github.com/owner/repo"
commit_sha = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

[[plugins.files]]
dir = "functions"
name = "_repo_foo.fish"

[[plugins.files]]
dir = "functions"
name = "_repo_bar.fish"

[[plugins.files]]
dir = "completions"
name = "repo.fish"

[[plugins]]
name = "repo2"
source = "https://github.com/owner/repo2"

[[plugins.files]]
dir = "functions"
name = "repo2.fish"

[[plugins.files]]
dir = "conf.d"
name = "repo2.fish"
```

## License

MIT

## Author

[tetzng](https://github.com/tetzng)
</file>

<file path=".tetzng/todo.md">
- [ ] anyhow によるエラーハンドリングを追加する
- [ ] テストを書く
- [ ] ドキュメントを書く
- [ ] upgrade コマンドの実装
- [ ] list コマンドの実装
- [ ] prune コマンドの実装
- [ ] log 出力を追加する
- [ ]
</file>

<file path="src/cmd/completion.rs">
use crate::cli;
use clap::CommandFactory;
use std::io;

pub(crate) fn generate_completion<G: clap_complete::Generator>(r#gen: G) {
    let mut cmd = cli::Cli::command();
    clap_complete::generate(r#gen, &mut cmd, "pez", &mut io::stdout());
}
</file>

<file path="src/tests_support/mod.rs">
#[cfg(test)]
pub mod env;
</file>

<file path=".gitignore">
/target
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization

- `src/main.rs` – binary entrypoint; logging setup and CLI dispatch.
- `src/cli.rs` – Clap args, flags (`-v/--verbose`), and subcommands.
- `src/cmd/` – subcommand implementations: `init`, `install`, `uninstall`, `upgrade`, `list`, `prune`, `completion`, `doctor`, `migrate`.
- Core: `models.rs` (shared types: PluginRepo/InstallTarget/ResolvedInstallTarget/TargetDir),
  `config.rs` (pez.toml), `lock_file.rs` (pez-lock.toml), `git.rs` (Git ops),
  `resolver.rs` (version/branch/tag/commit selection), `utils.rs` (paths/I/O/events).
- Tests helpers: `src/tests_support/`.

## Docs

- README (overview, quick start): `README.md`
- Getting started: `docs/getting-started.md`
- Command reference: `docs/commands.md`
- Configuration and lockfile: `docs/configuration.md`
- Architecture and flows: `docs/architecture.md`
- Install & build: `docs/install.md`
- FAQ: `docs/faq.md`

## Build, Test, and Development Commands

- Build: `cargo build` (or `--release`).
- Run: `cargo run -- <cmd>` (e.g., `cargo run -- install owner/repo@v3`).
- Test: `cargo test --all-features` (offline, deterministic).
- Format: `cargo fmt --all` (CI enforces `-- --check`).
- Lint: `cargo clippy --all-targets --all-features -- -D warnings`.
- Docs: `cargo doc --no-deps`.

## Concurrency Notes

- `PEZ_JOBS` bounds parallelism in `upgrade`, `uninstall`, and `prune`.
- `install` spawns clone tasks concurrently without an explicit job cap; the copy
  phase runs sequentially with duplicate‑path detection to avoid collisions.

## Coding Style & Naming Conventions

- Rust 2024; 4‑space indent; tidy imports.
- Names: modules/functions `snake_case`; types/enums `PascalCase`; consts `SCREAMING_SNAKE_CASE`.
- Errors: return `anyhow::Result<T>`; prefer `?` with `anyhow::Context` over `unwrap()` outside tests.
- Logging: `tracing` (`info!`, `warn!`, `error!`, `debug!`); verbosity via `-v/--verbose` or `RUST_LOG`.

## Testing Guidelines

- Place unit tests under `#[cfg(test)]` at file end; helpers in `tests_support`.
- Tests must be hermetic: no network, no real home dir; use temporary dirs and helper env.
- Name tests descriptively (e.g., `resolves_version_prefix_to_latest_patch`).
- Run with `cargo test --all-features`.

## Commit & Pull Request Guidelines

- Use Conventional Commits (`feat:`, `fix:`, `refactor:`, `test:`, `docs:`, `chore:`).
- Keep PRs focused; describe motivation/behavior and link issues.
- Include CLI output for user-visible changes; update README when flags or schema change.
- CI must pass (fmt, clippy, tests) before merge.

## Pre‑PR Checklist (Mandatory)

- Run `cargo fmt --all` and ensure there are no formatting diffs.
- Run `cargo clippy --all-features -- -D warnings` and fix all diagnostics.
- Run `cargo test --all-features` and ensure all tests pass (offline/hermetic).

## Security & Configuration Tips

- Do not log secrets; add context to errors (`.context("…")`).
- Avoid `process::exit` in non-`main` code; bubble errors.
- Respect env vars: `PEZ_CONFIG_DIR`, `PEZ_DATA_DIR`, `__fish_config_dir`, `__fish_user_data_dir`, `XDG_*`.
- Tests must remain offline; mock repos with temp dirs if needed.

## Open TODOs (as of 2025-09-15)

- Git credentials: unify fetch callbacks with clone (`Cred::default()`), or add robust fallback, to avoid HTTPS default_branch/fetch failures. Touchpoints: `git::fetch_all`, `git::get_latest_remote_commit`.
- List output safety: avoid panic on short SHAs; truncate safely instead of `p.commit_sha[..7]`.
- Install dedupe policy: use `copy_plugin_files` with dedupe for `install_all` as well, matching targeted `install` behavior. Decide on skip‑vs‑overwrite policy and document it.
- Prune in install_all: update lock file once per plugin (not per file) to reduce I/O; adjust `remove/save` placement.
- Runtime `unwrap()`: replace in non‑test paths with `?` and `anyhow::Context` to prevent crashes on I/O errors.
- Optional: bound `install` clone concurrency by `PEZ_JOBS` (today unbounded) for large target sets.

### Feature parity with previously planned phases (not yet on `main`)

- Upgrade selectors (Phase‑1): make `upgrade` honor selectors from `pez.toml` (`version`/`branch`/`tag`/`commit`) with clear pin/float semantics; add migration notes.
- Install parallel from pez.toml (Phase‑2): parallelize `pez install` (no targets) using `PEZ_JOBS`; ensure stable logs and error handling.
- `PEZ_TARGET_DIR` support (Phase‑3): allow overriding copy/remove/doctor target base; document theme discovery caveats.
- list `--filter` and selector column (Phase‑4): add regex filter (name/repo/source) and expose selector column in table/json; add tests and docs.
- `uninstall --stdin` (Phase‑5): expose CLI flag; robust parser (ignore blanks/comments); error on empty input; tests included.
- Packaging/release workflow (Phase‑6): add `.github/workflows/release.yaml` to build binaries on tag push and upload artifacts; update install docs.
- Docs sync (Phase‑7): merge the restructured English docs (`docs/*`) and refreshed README to `main` once approved.

### Robustness of `list --outdated`

- Handle repos without an upstream set or missing remote branches by falling back to `origin/HEAD` resolution; degrade gracefully with warnings instead of errors.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Teppei Taguchi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="docs/architecture.md">
# Architecture

This document outlines the high‑level structure and flows in pez.

## Overview

- `main.rs` initializes logging and dispatches to subcommands defined in `cli.rs` and implemented under `cmd/*`.
- Core modules:
  - `models.rs`: shared domain types (PluginRepo, InstallTarget, ResolvedInstallTarget, TargetDir).
  - `config.rs`: load/save `pez.toml`, convert entries to install targets.
  - `lock_file.rs`: load/save `pez-lock.toml`, track installed plugins and copied files.
  - `resolver.rs`: parse refs (latest/version/tag/branch/commit) and map to `Selection`.
  - `git.rs`: resolve selections against a repo (branches/tags/commits), list tags.
  - `utils.rs`: path/env resolution, copy routines, events, helpers.
  - `cmd/*`: end‑user commands orchestrating core modules.

## Data Flow (install)

1. Normalize CLI targets (or entries in `pez.toml`) into `InstallTarget` values.
2. Convert each `InstallTarget` to a `ResolvedInstallTarget` (source, ref_kind, is_local).
3. Clone remote sources; skip clone for local paths.
4. Resolve the commit using `resolver::RefKind` → `git::resolve_selection`.
5. Copy files to the Fish config directory using `utils::copy_plugin_files*`.
6. Update the lockfile with `name`/`repo`/`source`/`commit_sha`/`files`.
7. For files under `conf.d`, emit `fish -c 'emit <stem>_{install|update|uninstall}'` events.

## Concurrency

- `PEZ_JOBS` controls concurrency for `upgrade`, `uninstall`, and `prune`.
- `install` concurrency depends on how it is invoked:
  - With explicit targets (`install <targets...>`): clones run concurrently (unbounded), file copies run sequentially with duplicate‑path detection and warnings.
  - From `pez.toml` (no targets): processing is sequential and destination files are overwritten.

## Paths and Resolution

- Config dir precedence: `PEZ_CONFIG_DIR` → `__fish_config_dir` → `XDG_CONFIG_HOME/fish` → `~/.config/fish`.
- Data dir precedence: `PEZ_DATA_DIR` → `__fish_user_data_dir/pez` → `XDG_DATA_HOME/fish/pez` → `~/.local/share/fish/pez`.
- Copy destination: always the Fish config directory; overriding the target base via an env var is not supported.

## Upgrade Semantics

- Local sources are skipped.
- Non‑local plugins update to the latest commit on the remote default branch (remote HEAD).
- Selectors in `pez.toml` (version/branch/tag/commit) are not used by `upgrade`; they are honored on fresh installs and on `install --force`.
</file>

<file path="docs/commands.md">
# Command Reference

Global options

- `-v, --verbose` Increase verbosity. Default is info; `-vv` enables debug.
- `-V, --version` Print version.
- `-h, --help` Print help.

## init

- Initialize `pez.toml` under the configuration directory. Fails if it already exists.

## install

- Install from CLI targets or from `pez.toml` (when no targets are given).
- Targets: `owner/repo[@ref]`, `host/owner/repo[@ref]`, full URL, absolute/`~/` paths.
- Options: `--force`, `--prune` (remove lockfile entries not present in `pez.toml`).
- Behavior:
  - CLI‑specified targets are appended to `pez.toml` (relative paths are normalized to absolute).
  - `owner/repo` resolves to `https://github.com/owner/repo`; `host/...` without a scheme is normalized to `https://host/...`.
  - Selectors: `@latest`, `@version:<v>`, `@branch:<b>`, `@tag:<t>`, `@commit:<sha>` influence the resolved commit for fresh installs and `install --force`.
  - Concurrency: with explicit targets, clones run concurrently and file copies run sequentially with duplicate‑path detection; from `pez.toml` (no targets), processing is sequential and destination files are overwritten.

## uninstall

- Remove the specified plugins (`owner/repo`). At least one plugin must be provided.
- Options: `--force` (remove destination files even if the repo directory is missing).
- Behavior: removes the cloned repo (if present) and files recorded in `pez-lock.toml`. Without `--force` and a missing repo directory, the command lists the files and aborts.

## upgrade

- Upgrades specified plugins (`owner/repo ...`), or with no arguments, upgrades plugins listed in `pez.toml`.
- For non‑local plugins, update to the latest commit on the remote's default branch (remote HEAD). Local sources are skipped.
- Selectors in `pez.toml` (version/branch/tag/commit) are not applied by `upgrade`; they affect initial install and re‑install with `install --force`.
- Concurrency is controlled by `PEZ_JOBS`.

## list

- Show installed plugins from `pez-lock.toml`.
- Options: `--format [plain|table|json]`, `--outdated`.
- JSON fields:
  - `list`: `name`, `repo`, `source`, `commit`
  - `list --outdated`: `name`, `repo`, `source`, `current`, `latest`

## prune

- Remove plugins that exist only in the lockfile (i.e., not listed in `pez.toml`).
- Options: `--dry-run`, `--yes`, `--force` (remove destination files even if the repo dir is missing).
- Behavior: if `pez.toml` is empty, the command warns and asks for confirmation unless `--yes` is provided.

## doctor

- Checks the configuration file, lockfile, data/config directories, and the set of copied files.
- Reported checks include: `config`, `lock_file`, `fish_config_dir`, `pez_data_dir`, `repos` (missing clones), `target_files` (missing files), `duplicates` (conflicting destinations).
- Options: `--format json`.

## completions

- Generate completion script for Fish: `pez completions fish > ~/.config/fish/completions/pez.fish`

## migrate

- Import from fisher’s `fish_plugins` into `pez.toml`.
- Options: `--dry-run`, `--force`, `--install`.
</file>

<file path="docs/configuration.md">
# Configuration and Lockfile

This document describes the user‑facing configuration files used by pez.

## pez.toml

Define the plugins you want pez to manage. Each entry must specify exactly one
source kind and at most one version selector.

Rules

- Source: choose exactly one of `repo` (GitHub shorthand), `url` (full Git URL), or `path` (local directory).
- Selector: choose at most one of `version`, `branch`, `tag`, or `commit`.

GitHub shorthand (repo source)

```toml
[[plugins]]
repo = "owner/repo"
# version = "latest"   # default if omitted; or "v3" (branch preferred over tags)
# branch  = "main"
# tag     = "v1.2.3"
# commit  = "<sha>"    # 7+ chars recommended
```

Generic Git host (url source)

```toml
[[plugins]]
url = "https://gitlab.com/owner/repo"
# version = "v3"
# branch  = "main"
# tag     = "v1.2.3"
# commit  = "<sha>"
```

Local directory (path source)

```toml
[[plugins]]
path = "~/path/to/local/plugin"   # absolute or ~/ only
```

Notes

- If a URL has no scheme, pez normalizes it to https (e.g., `gitlab.com/...`).
- CLI‑provided relative paths are normalized to absolute paths when recorded.
- `path` must resolve to an absolute path (either absolute or `~/…`).

## pez-lock.toml

Machine‑generated; do not edit. The lock file records the concrete state pez has
installed: `name`, `repo`, `source`, `commit_sha`, and copied `files`.

Example

```toml
version = 1

[[plugins]]
name = "repo"
repo = "owner/repo"
source = "https://github.com/owner/repo"
commit_sha = "abc1234..."

  [[plugins.files]]
  dir = "functions"
  name = "foo.fish"

  [[plugins.files]]
  dir = "conf.d"
  name = "bar.fish"
```

Notes

- For local sources, `commit_sha = "local"`. Such entries are skipped by
  `upgrade` and excluded from `list --outdated` comparisons.

## Environment Variables

- `PEZ_CONFIG_DIR` — Directory containing `pez.toml` and `pez-lock.toml`.
- `PEZ_DATA_DIR` — Base directory for cloned plugin repositories.
- `__fish_config_dir` / `XDG_CONFIG_HOME` — Fish configuration directory.
- `__fish_user_data_dir` / `XDG_DATA_HOME` — Fish data directory.
- `PEZ_JOBS` — Concurrency for `upgrade`, `uninstall`, and `prune` (default: 4).
- `RUST_LOG` — Log filtering (takes precedence over `-v`).
</file>

<file path="docs/faq.md">
## FAQ

### Where does pez put files?

pez copies plugin files into your Fish config directory (`functions`, `completions`, `conf.d`, `themes`). See docs/configuration.md for directory precedence.

### Where are plugin repos cloned?

Under the pez data directory (by default `~/.local/share/fish/pez`). You can override via `PEZ_DATA_DIR`.

### Why doesn't `upgrade` change my plugin pinned by tag/branch in pez.toml?

`upgrade` updates non‑local plugins to the remote default branch HEAD and ignores selectors. Selectors are honored for fresh installs and `install --force`.

### How are duplicates handled when copying files?

- CLI targets (`pez install owner/repo ...`): duplicate destination paths are skipped with a warning.
- From `pez.toml` (`pez install` with no targets): existing files are overwritten.

### How do I uninstall everything not in pez.toml?

Run `pez prune`. Use `--dry-run` to preview and `--yes` to skip confirmation when `pez.toml` is empty.

### How do I use a local plugin?

Add `[[plugins]] path = "~/path/to/plugin"`. Local sources are not upgraded and are excluded from `list --outdated`.

### I installed the same repo twice with a different name — is that supported?

The lockfile deduplicates by repo/name. Prefer a single install per repo. If you need a custom display name, set `name = "..."` in the plugin spec.
</file>

<file path="docs/getting-started.md">
## Getting started

### Quick start

1) Initialize configuration (creates `pez.toml`)

```shell
pez init
```

2) Add a plugin to `pez.toml` (choose one of repo/url/path)

```toml
[[plugins]]
repo = "owner/repo"      # GitHub shorthand
# version = "v3"        # Or: tag = "...", branch = "...", commit = "..."

## Or a full Git URL
# [[plugins]]
# url = "https://gitlab.com/owner/repo"
# branch = "main"

## Or a local directory (absolute or ~/ only)
# [[plugins]]
# path = "~/path/to/local/plugin"
```

3) Install and list

```shell
pez install
pez list --format table
```

4) Optional: enable completions for pez itself

```shell
pez completions fish > ~/.config/fish/completions/pez.fish
```

### CLI usage (examples)

| Command | Purpose | Example |
| --- | --- | --- |
| `pez init` | Create `pez.toml` | `pez init` |
| `pez install` | Install from `pez.toml` | `pez install` |
| `pez install <target>` | Install a specific plugin | `pez install owner/repo@v3` |
| `pez uninstall <repo>` | Uninstall a plugin | `pez uninstall owner/repo` |
| `pez upgrade` | Update non‑local plugins to remote HEAD | `pez upgrade` |
| `pez list --outdated` | Show outdated plugins | `pez list --outdated --format json` |
| `pez doctor` | Run diagnostics | `pez doctor --format json` |

Key flag: `-v/--verbose` increases logging (`-vv` enables debug).

### Notes

- Selectors (version/branch/tag/commit) are honored on fresh installs and on `install --force`; they are not applied by `upgrade`.
- When installing explicit targets on the CLI, duplicate destination paths are skipped with a warning. When installing from `pez.toml` (no targets), existing files are overwritten.
</file>

<file path="docs/install.md">
## Install & build

### System requirements

- Fish shell (for using the installed plugins)
- Git (for cloning plugin repositories)
- Rust toolchain (stable), Cargo available

### Install

Install with Cargo (from crates.io if available):

```shell
cargo install pez
```

From source (this repo):

```shell
cargo install --path .
```

### Build from source

```shell
cargo build --release
./target/release/pez -V
```

### Shell completions

```shell
pez completions fish > ~/.config/fish/completions/pez.fish
```
</file>

<file path="src/cmd/doctor.rs">
use crate::{cli, lock_file::LockFile, utils};
use serde_derive::Serialize;
use serde_json::json;
use std::{collections::HashSet, path};
use tracing::{info, warn};

#[derive(Serialize)]
struct DoctorCheck<'a> {
    name: &'a str,
    status: &'a str, // ok | warn | error
    details: String,
}

pub(crate) fn run(args: &cli::DoctorArgs) -> anyhow::Result<()> {
    let mut checks: Vec<DoctorCheck> = Vec::new();

    match utils::load_config() {
        Ok((_cfg, path)) => checks.push(DoctorCheck {
            name: "config",
            status: "ok",
            details: format!("found: {}", path.display()),
        }),
        Err(_) => checks.push(DoctorCheck {
            name: "config",
            status: "warn",
            details: "pez.toml not found".to_string(),
        }),
    }

    let mut lock: Option<LockFile> = None;
    match utils::load_lock_file() {
        Ok((l, path)) => {
            lock = Some(l);
            checks.push(DoctorCheck {
                name: "lock_file",
                status: "ok",
                details: format!("found: {}", path.display()),
            })
        }
        Err(_) => checks.push(DoctorCheck {
            name: "lock_file",
            status: "warn",
            details: "pez-lock.toml not found".to_string(),
        }),
    }

    let fish_config_dir = utils::load_fish_config_dir()?;
    checks.push(DoctorCheck {
        name: "fish_config_dir",
        status: if fish_config_dir.exists() {
            "ok"
        } else {
            "warn"
        },
        details: fish_config_dir.display().to_string(),
    });

    let pez_data_dir = utils::load_pez_data_dir()?;
    checks.push(DoctorCheck {
        name: "pez_data_dir",
        status: if pez_data_dir.exists() { "ok" } else { "warn" },
        details: pez_data_dir.display().to_string(),
    });

    if let Some(lock_file) = lock {
        let mut missing_repos = vec![];
        for p in &lock_file.plugins {
            let repo_path = pez_data_dir.join(p.repo.as_str());
            if !repo_path.exists() {
                missing_repos.push(p.repo.as_str());
            }
        }
        checks.push(DoctorCheck {
            name: "repos",
            status: if missing_repos.is_empty() {
                "ok"
            } else {
                "warn"
            },
            details: if missing_repos.is_empty() {
                "all cloned".to_string()
            } else {
                format!("missing: {}", missing_repos.join(", "))
            },
        });

        let mut missing_files = vec![];
        let mut dest_set: HashSet<path::PathBuf> = HashSet::new();
        let mut duplicates = vec![];
        for p in &lock_file.plugins {
            for f in &p.files {
                let dest = fish_config_dir.join(f.dir.as_str()).join(&f.name);
                if !dest.exists() {
                    missing_files.push(dest.display().to_string());
                }
                if !dest_set.insert(dest.clone()) {
                    duplicates.push(dest.display().to_string());
                }
            }
        }
        checks.push(DoctorCheck {
            name: "target_files",
            status: if missing_files.is_empty() {
                "ok"
            } else {
                "warn"
            },
            details: if missing_files.is_empty() {
                "all present".to_string()
            } else {
                format!("missing: {}", missing_files.join(", "))
            },
        });
        checks.push(DoctorCheck {
            name: "duplicates",
            status: if duplicates.is_empty() { "ok" } else { "error" },
            details: if duplicates.is_empty() {
                "no conflicts".to_string()
            } else {
                format!("conflicting destinations: {}", duplicates.join(", "))
            },
        });
    }

    match args.format {
        Some(cli::DoctorFormat::Json) => {
            println!("{}", serde_json::to_string_pretty(&json!(checks))?);
        }
        None => {
            info!("pez doctor checks:");
            for c in &checks {
                let prefix = match c.status {
                    "ok" => "✔",
                    "warn" => "⚠",
                    _ => "✖",
                };
                println!("{} {:<12} - {}", prefix, c.name, c.details);
            }
            if checks.iter().any(|c| c.status == "error") {
                warn!("Errors detected. Please resolve the above items.");
            }
        }
    }

    Ok(())
}
</file>

<file path="src/cmd/init.rs">
use tracing::info;

use crate::utils;
use std::{fs, path};

pub(crate) fn run() -> anyhow::Result<()> {
    let config_dir = utils::load_pez_config_dir()?;
    create_config(&config_dir)
}

fn create_config(config_dir: &path::Path) -> anyhow::Result<()> {
    if !config_dir.exists() {
        fs::create_dir_all(config_dir)?;
    }

    let config_path = config_dir.join("pez.toml");
    if config_path.exists() {
        anyhow::bail!("{} already exists", config_path.display());
    }

    let contents = r#"# This file defines the plugins to be installed by pez.

# Examples of plugins:
# [[plugins]]
# repo = "owner/repo"      # GitHub shorthand
# # version = "v3"        # Or: tag = "...", branch = "...", commit = "..."
# # name = "custom-name"   # Optional display name

# [[plugins]]
# url = "https://gitlab.com/owner/repo"  # Any Git host URL
# # branch = "main"

# [[plugins]]
# path = "~/path/to/local/plugin"       # Local directory

# Add more plugins by copying the [[plugins]] block.
"#;
    fs::write(&config_path, contents)?;
    info!("Created {}", config_path.display());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    #[test]
    fn test_create_config() {
        let temp_dir = tempfile::tempdir().unwrap();
        let config_dir = temp_dir.path();
        let config_path = config_dir.join("pez.toml");
        let result = create_config(config_dir);

        assert!(result.is_ok());
        assert!(config_path.exists());

        let contents = fs::read_to_string(&config_path).unwrap();
        assert!(contents.contains("[[plugins]]"));
        assert!(contents.contains("repo = \"owner/repo\""));
    }

    #[test]
    fn test_create_config_already_exists() {
        let temp_dir = tempfile::tempdir().unwrap();
        let config_dir = temp_dir.path();
        let config_path = config_dir.join("pez.toml");
        fs::write(&config_path, "").unwrap();

        let result = create_config(config_dir);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            format!("{} already exists", config_path.display())
        );
    }
}
</file>

<file path=".github/workflows/ci.yaml">
name: CI
permissions:
  contents: read

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    name: cargo test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta, nightly]
    steps:
      - uses: actions/checkout@v5
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - run: cargo test --all-features
  formatting:
    name: cargo fmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          components: rustfmt
      - name: rustfmt check
        uses: actions-rust-lang/rustfmt@v1
  clippy_check:
    name: cargo clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: "Install/Update the Rust version"
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          components: clippy
      - name: clippy "No Default Features"
        run: cargo clippy --workspace --no-default-features --all-targets
      - name: clippy "Default"
        run: cargo clippy --workspace --all-targets
      - name: clippy "All Features"
        run: cargo clippy --workspace --all-features --all-targets
</file>

<file path="src/cmd/mod.rs">
pub mod completion;
pub mod doctor;
pub mod init;
pub mod install;
pub mod list;
pub mod migrate;
pub mod prune;
pub mod uninstall;
pub mod upgrade;
</file>

<file path="src/models.rs">
use regex::Regex;
use serde_derive::{Deserialize, Serialize};

// Generic destination directory kinds for fish assets

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub(crate) enum TargetDir {
    #[serde(rename = "functions")]
    Functions,
    #[serde(rename = "completions")]
    Completions,
    #[serde(rename = "conf.d")]
    ConfD,
    #[serde(rename = "themes")]
    Themes,
}

impl TargetDir {
    pub(crate) fn as_str(&self) -> &str {
        match self {
            TargetDir::Functions => "functions",
            TargetDir::Completions => "completions",
            TargetDir::ConfD => "conf.d",
            TargetDir::Themes => "themes",
        }
    }
    pub(crate) fn all() -> Vec<Self> {
        vec![
            TargetDir::Functions,
            TargetDir::Completions,
            TargetDir::ConfD,
            TargetDir::Themes,
        ]
    }
}

impl std::str::FromStr for TargetDir {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "functions" => Ok(TargetDir::Functions),
            "completions" => Ok(TargetDir::Completions),
            "conf.d" => Ok(TargetDir::ConfD),
            "themes" => Ok(TargetDir::Themes),
            _ => Err(format!("Invalid target dir: {s}")),
        }
    }
}

// Core typed identifiers and inputs used across CLI and core logic

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(try_from = "String", into = "String")]
pub(crate) struct PluginRepo {
    pub owner: String,
    pub repo: String,
}

impl TryFrom<String> for PluginRepo {
    type Error = String;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        value.parse()
    }
}

impl From<PluginRepo> for String {
    fn from(plugin_repo: PluginRepo) -> Self {
        plugin_repo.as_str()
    }
}

impl PluginRepo {
    pub fn as_str(&self) -> String {
        format!("{}/{}", self.owner, self.repo)
    }
}

impl std::fmt::Display for PluginRepo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for PluginRepo {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let re = Regex::new(r"^[a-zA-Z0-9-]+/[a-zA-Z0-9_.-]+$").unwrap();
        if re.is_match(s) && !s.ends_with('.') {
            let parts: Vec<&str> = s.split('/').collect();
            Ok(PluginRepo {
                owner: parts[0].to_string(),
                repo: parts[1].to_string(),
            })
        } else {
            Err(format!(
                "Invalid format: {s}. Expected format: <owner>/<repo>"
            ))
        }
    }
}

/// A user-supplied install target that can be a repo, URL, or local path.
/// Supported examples:
/// - `owner/repo`
/// - `owner/repo@v3`
/// - `gitlab.com/owner/repo`
/// - `gitlab.com/owner/repo@branch`
/// - <https://example.com/owner/repo>
/// - `~/path/to/repo` or `./relative/path`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(try_from = "String", into = "String")]
pub(crate) struct InstallTarget {
    pub(crate) raw: String,
}

impl TryFrom<String> for InstallTarget {
    type Error = String;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        Ok(InstallTarget { raw: value })
    }
}

impl From<InstallTarget> for String {
    fn from(val: InstallTarget) -> Self {
        val.raw
    }
}

impl std::str::FromStr for InstallTarget {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InstallTarget { raw: s.to_string() })
    }
}

/// Result of parsing an `InstallTarget` into concrete fields used by commands.
#[derive(Debug, Clone, PartialEq)]
pub(crate) struct ResolvedInstallTarget {
    pub plugin_repo: PluginRepo,
    /// Repository base source (URL or local path, without @ref).
    pub source: String,
    /// Optional ref selection.
    pub ref_kind: crate::resolver::RefKind,
    /// Whether the source is a local filesystem path.
    pub is_local: bool,
}
</file>

<file path="src/cmd/list.rs">
use crate::{cli, git, lock_file::Plugin, utils};

use console::Emoji;
use serde_json::json;
use std::io;
use tabled::{Table, Tabled};
use tracing::info;

#[derive(Debug, Tabled)]
struct PluginRow {
    name: String,
    repo: String,
    source: String,
    commit: String,
}

#[derive(Debug, Tabled)]
struct PluginOutdatedRow {
    name: String,
    repo: String,
    source: String,
    current: String,
    latest: String,
}

pub(crate) fn run(args: &cli::ListArgs) -> anyhow::Result<()> {
    let result = utils::load_lock_file();
    if result.is_err() {
        info!("No plugins installed!");
        return Ok(());
    }

    let (lock_file, _) = match result {
        Ok(v) => v,
        Err(_) => {
            info!("No plugins installed!");
            return Ok(());
        }
    };
    let plugins = &lock_file.plugins;
    if plugins.is_empty() {
        info!("No plugins installed!");
        return Ok(());
    }

    if args.outdated {
        match args.format.clone().unwrap_or(cli::ListFormat::Plain) {
            cli::ListFormat::Table => list_outdated_table(plugins)?,
            cli::ListFormat::Json => list_outdated_json(plugins)?,
            cli::ListFormat::Plain => list_outdated(plugins)?,
        }
    } else {
        match args.format.clone().unwrap_or(cli::ListFormat::Plain) {
            cli::ListFormat::Table => display_plugins_in_table(plugins),
            cli::ListFormat::Json => list_json(plugins)?,
            cli::ListFormat::Plain => list(plugins)?,
        }
    }

    Ok(())
}

fn list(plugins: &[Plugin]) -> anyhow::Result<()> {
    display_plugins(plugins, io::stdout())?;
    Ok(())
}

fn display_plugins<W: io::Write>(plugins: &[Plugin], mut writer: W) -> anyhow::Result<()> {
    for plugin in plugins {
        writeln!(writer, "{}", plugin.repo)?;
    }

    Ok(())
}

fn display_plugins_in_table(plugins: &[Plugin]) {
    let plugin_rows = plugins
        .iter()
        .map(|p| PluginRow {
            name: p.get_name(),
            repo: p.repo.as_str().clone(),
            source: p.source.clone(),
            commit: p.commit_sha[..7].to_string(),
        })
        .collect::<Vec<PluginRow>>();
    let table = Table::new(&plugin_rows);
    println!("{table}");
}

fn list_outdated(plugins: &[Plugin]) -> anyhow::Result<()> {
    let outdated_plugins = get_outdated_plugins(plugins)?;
    if outdated_plugins.is_empty() {
        info!("{}All plugins are up to date!", Emoji("🎉 ", ""));
        return Ok(());
    }
    display_plugins(&outdated_plugins, io::stdout())?;

    Ok(())
}

fn get_outdated_plugins(plugins: &[Plugin]) -> anyhow::Result<Vec<Plugin>> {
    let data_dir = utils::load_pez_data_dir()?;
    let outdated_plugins: Vec<Plugin> = plugins
        .iter()
        .filter(|p| {
            let repo_path = data_dir.join(p.repo.as_str());
            let latest_remote_commit = match git2::Repository::open(&repo_path)
                .ok()
                .and_then(|r| git::get_latest_remote_commit(&r).ok())
            {
                Some(s) => s,
                None => return false,
            };
            p.commit_sha != latest_remote_commit
        })
        .cloned()
        .collect();

    Ok(outdated_plugins)
}

fn list_outdated_table(plugins: &[Plugin]) -> anyhow::Result<()> {
    let data_dir = utils::load_pez_data_dir()?;
    let outdated_plugins = get_outdated_plugins(plugins)?;
    if outdated_plugins.is_empty() {
        info!("{}All plugins are up to date!", Emoji("🎉 ", ""));
        return Ok(());
    }

    let plugin_rows = outdated_plugins
        .iter()
        .map(|p| PluginOutdatedRow {
            name: p.get_name(),
            repo: p.repo.as_str().clone(),
            source: p.source.clone(),
            current: p.commit_sha[..7].to_string(),
            latest: {
                let repo_path = data_dir.join(p.repo.as_str());
                match git2::Repository::open(&repo_path)
                    .ok()
                    .and_then(|r| git::get_latest_remote_commit(&r).ok())
                {
                    Some(s) => s[..7].to_string(),
                    None => "—".to_string(),
                }
            },
        })
        .collect::<Vec<PluginOutdatedRow>>();
    let table = Table::new(&plugin_rows);
    println!("{table}");

    Ok(())
}

fn list_json(plugins: &[Plugin]) -> anyhow::Result<()> {
    let value = json!(
        plugins
            .iter()
            .map(|p| json!({
                "name": p.get_name(),
                "repo": p.repo.as_str(),
                "source": p.source,
                "commit": p.commit_sha,
            }))
            .collect::<Vec<_>>()
    );
    println!("{}", serde_json::to_string_pretty(&value)?);
    Ok(())
}

fn list_outdated_json(plugins: &[Plugin]) -> anyhow::Result<()> {
    let data_dir = utils::load_pez_data_dir()?;
    let outdated_plugins = get_outdated_plugins(plugins)?;
    if outdated_plugins.is_empty() {
        info!("{}All plugins are up to date!", Emoji("🎉 ", ""));
        return Ok(());
    }
    let value = json!(
        outdated_plugins
            .iter()
            .map(|p| {
                let repo_path = data_dir.join(p.repo.as_str());
                let latest = git2::Repository::open(&repo_path)
                    .ok()
                    .and_then(|r| git::get_latest_remote_commit(&r).ok())
                    .unwrap_or_default();
                json!({
                    "name": p.get_name(),
                    "repo": p.repo.as_str(),
                    "source": p.source,
                    "current": p.commit_sha,
                    "latest": latest,
                })
            })
            .collect::<Vec<_>>()
    );
    println!("{}", serde_json::to_string_pretty(&value)?);
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lock_file::Plugin;
    use crate::models::PluginRepo;

    #[test]
    fn test_display_plugins() {
        let plugins = vec![
            Plugin {
                name: "name".to_string(),
                repo: PluginRepo {
                    owner: "owner".to_string(),
                    repo: "repo".to_string(),
                },
                source: "source".to_string(),
                commit_sha: "commit_sha".to_string(),
                files: vec![],
            },
            Plugin {
                name: "name2".to_string(),
                repo: PluginRepo {
                    owner: "owner".to_string(),
                    repo: "repo2".to_string(),
                },
                source: "source2".to_string(),
                commit_sha: "commit_sha2".to_string(),
                files: vec![],
            },
        ];

        let mut output = io::Cursor::new(Vec::new());
        display_plugins(&plugins, &mut output).unwrap();

        let actual_output = String::from_utf8(output.into_inner()).unwrap();
        let expected_output = "owner/repo\nowner/repo2\n";

        assert_eq!(actual_output, expected_output);
    }
}
</file>

<file path="src/tests_support/env.rs">
use crate::lock_file::PluginFile;
use crate::models::PluginRepo;
use crate::{config, lock_file::LockFile};
use std::{fs, path};

pub(crate) struct TestEnvironmentSetup {
    pub(crate) _temp_dir: tempfile::TempDir,
    pub(crate) fish_config_dir: path::PathBuf,
    #[allow(dead_code)]
    pub(crate) config_dir: path::PathBuf,
    pub(crate) data_dir: path::PathBuf,
    pub(crate) config: Option<config::Config>,
    pub(crate) config_path: path::PathBuf,
    pub(crate) lock_file: Option<LockFile>,
    pub(crate) lock_file_path: path::PathBuf,
}

impl TestEnvironmentSetup {
    pub(crate) fn new() -> Self {
        let temp_dir = tempfile::tempdir().unwrap();
        let fish_config_dir = temp_dir.path().join("fish");
        fs::create_dir_all(&fish_config_dir).unwrap();

        let config_dir = temp_dir.path().join("pez");
        fs::create_dir_all(&config_dir).unwrap();

        let data_dir = temp_dir.path().join("data");
        fs::create_dir_all(&data_dir).unwrap();

        let config_path = config_dir.join("pez.toml");
        let lock_file_path = config_dir.join("pez-lock.toml");

        Self {
            _temp_dir: temp_dir,
            fish_config_dir,
            config_dir,
            data_dir,
            config: None,
            config_path,
            lock_file: None,
            lock_file_path,
        }
    }

    pub(crate) fn setup_config(&mut self, config: config::Config) {
        self.config = Some(config.clone());
        config.save(&self.config_path).unwrap();
    }

    pub(crate) fn setup_lock_file(&mut self, lock_file: LockFile) {
        self.lock_file = Some(lock_file.clone());
        lock_file.save(&self.lock_file_path).unwrap();
    }

    pub(crate) fn setup_data_repo(&self, repos: Vec<PluginRepo>) {
        for repo in repos {
            let repo_path = self.data_dir.join(repo.as_str());
            fs::create_dir_all(repo_path).unwrap();
        }
    }

    pub(crate) fn add_plugin_files_to_repo(&self, repo: &PluginRepo, files: &[PluginFile]) {
        let repo_path = self.data_dir.join(repo.as_str());
        for file in files {
            let dir = repo_path.join(file.dir.as_str());
            let file_path = dir.join(file.name.as_str());
            if let Some(parent) = file_path.parent() {
                fs::create_dir_all(parent).unwrap();
            } else if !dir.exists() {
                fs::create_dir_all(&dir).unwrap();
            }
            fs::File::create(file_path).unwrap();
        }
    }

    pub(crate) fn setup_fish_config(&self) {
        self.lock_file
            .as_ref()
            .unwrap()
            .plugins
            .iter()
            .for_each(|plugin| {
                plugin.files.iter().for_each(|file| {
                    let dest_path = file.get_path(&self.fish_config_dir);
                    fs::create_dir_all(dest_path.parent().unwrap()).unwrap();
                    fs::File::create(dest_path).unwrap();
                });
            });
    }
}

impl LockFile {
    pub(crate) fn get_plugin_repos(&self) -> Vec<PluginRepo> {
        self.plugins.iter().map(|p| p.repo.clone()).collect()
    }
}

impl config::Config {
    #[allow(dead_code)]
    pub(crate) fn get_plugin_repos(&self) -> Vec<PluginRepo> {
        self.plugins
            .as_ref()
            .unwrap()
            .iter()
            .filter_map(|p| p.get_plugin_repo().ok())
            .collect()
    }
}
</file>

<file path="src/cmd/migrate.rs">
use crate::{
    cli::{InstallArgs, MigrateArgs},
    config, utils,
};
use console::Emoji;
use std::{
    fs,
    io::{BufRead, BufReader},
};
use tracing::{error, info, warn};

pub(crate) async fn run(args: &MigrateArgs) -> anyhow::Result<()> {
    let fish_config_dir = utils::load_fish_config_dir()?;
    let fisher_plugins_path = fish_config_dir.join("fish_plugins");
    if !fisher_plugins_path.exists() {
        error!(
            "{}fish_plugins not found at {}",
            Emoji("❌ ", ""),
            fisher_plugins_path.display()
        );
        anyhow::bail!("fish_plugins not found");
    }

    info!(
        "{}Reading {}",
        Emoji("📄 ", ""),
        fisher_plugins_path.display()
    );

    let file = fs::File::open(&fisher_plugins_path)?;
    let reader = BufReader::new(file);
    let mut repos: Vec<crate::models::PluginRepo> = Vec::new();
    for line in reader.lines() {
        let line = line?;
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        match trimmed.parse::<crate::models::PluginRepo>() {
            Ok(repo) => {
                if repo.owner == "jorgebucaran" && repo.repo == "fisher" {
                    continue;
                }
                repos.push(repo)
            }
            Err(_) => warn!(
                "{}Skipping unrecognized entry: {}",
                Emoji("⚠ ", ""),
                trimmed
            ),
        }
    }

    if repos.is_empty() {
        warn!("{}No valid entries to migrate.", Emoji("⚠ ", ""));
        return Ok(());
    }

    let (mut cfg, cfg_path) = utils::load_or_create_config()?;
    let mut planned = Vec::new();
    match cfg.plugins.as_mut() {
        Some(list) => {
            if args.force {
                planned = repos
                    .iter()
                    .map(|r| config::PluginSpec {
                        name: None,
                        source: config::PluginSource::Repo {
                            repo: r.clone(),
                            version: None,
                            branch: None,
                            tag: None,
                            commit: None,
                        },
                    })
                    .collect();
                if !args.dry_run {
                    cfg.plugins = Some(planned.clone());
                }
            } else {
                for r in repos {
                    if !list
                        .iter()
                        .any(|p| p.get_plugin_repo().is_ok_and(|pr| pr == r))
                    {
                        planned.push(config::PluginSpec {
                            name: None,
                            source: config::PluginSource::Repo {
                                repo: r.clone(),
                                version: None,
                                branch: None,
                                tag: None,
                                commit: None,
                            },
                        });
                        if !args.dry_run {
                            list.push(config::PluginSpec {
                                name: None,
                                source: config::PluginSource::Repo {
                                    repo: r,
                                    version: None,
                                    branch: None,
                                    tag: None,
                                    commit: None,
                                },
                            });
                        }
                    }
                }
            }
        }
        None => {
            planned = repos
                .iter()
                .map(|r| config::PluginSpec {
                    name: None,
                    source: config::PluginSource::Repo {
                        repo: r.clone(),
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                })
                .collect();
            if !args.dry_run {
                cfg.plugins = Some(planned.clone());
            }
        }
    }

    if args.dry_run {
        info!("{}Dry run: planned updates to pez.toml", Emoji("🧪 ", ""));
    } else {
        cfg.save(&cfg_path)?;
        info!("{}Updated {}", Emoji("✅ ", ""), cfg_path.display());
    }
    for p in &planned {
        println!(
            "  - {}",
            p.get_plugin_repo().map(|r| r.as_str()).unwrap_or_default()
        );
    }
    if planned.is_empty() {
        info!("{}Nothing to update.", Emoji("ℹ ", ""));
    }

    if !args.dry_run && args.install && !planned.is_empty() {
        let targets: Vec<_> = planned
            .iter()
            .filter_map(|p| p.get_plugin_repo().ok())
            .map(|r| crate::models::InstallTarget::from_raw(r.as_str()))
            .collect();
        let install_args = InstallArgs {
            plugins: Some(targets),
            force: false,
            prune: false,
        };
        info!("{}Installing migrated plugins...", Emoji("🚀 ", ""));
        crate::cmd::install::run(&install_args).await?;
    }
    Ok(())
}
</file>

<file path="src/cmd/prune.rs">
use crate::{
    cli::PruneArgs,
    config,
    lock_file::{LockFile, Plugin},
    utils,
};
use console::Emoji;
use futures::{StreamExt, stream};
use std::{fs, io, path};
use tracing::{info, warn};

struct PruneContext<'a> {
    fish_config_dir: &'a path::Path,
    data_dir: &'a path::Path,
    config: &'a config::Config,
    lock_file: &'a mut LockFile,
    lock_file_path: &'a path::Path,
}

pub(crate) async fn run(args: &PruneArgs) -> anyhow::Result<()> {
    let fish_config_dir = utils::load_fish_config_dir()?;
    let data_dir = utils::load_pez_data_dir()?;
    let (config, _) = utils::load_config()?;
    let (mut lock_file, lock_file_path) = utils::load_lock_file()?;
    let mut ctx = PruneContext {
        fish_config_dir: &fish_config_dir,
        data_dir: &data_dir,
        config: &config,
        lock_file: &mut lock_file,
        lock_file_path: &lock_file_path,
    };

    if args.dry_run {
        info!("{}Starting dry run prune process...", Emoji("🔍 ", ""));
        dry_run(args.force, &mut ctx)?;
        info!(
            "\n{}Dry run completed. No files have been removed.",
            Emoji("🎉 ", "")
        );
    } else {
        info!("{}Starting prune process...", Emoji("🔍 ", ""));
        prune_parallel(args.force, args.yes, &mut ctx).await?;
    }

    Ok(())
}

fn confirm_removal() -> anyhow::Result<bool> {
    warn!(
        "{}Are you sure you want to continue? [y/N]",
        Emoji("🚧 ", "")
    );
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_lowercase() == "y")
}

fn find_unused_plugins(
    config: &config::Config,
    lock_file: &LockFile,
) -> anyhow::Result<Vec<Plugin>> {
    if config.plugins.is_none() {
        return Ok(lock_file.plugins.clone());
    }

    Ok(lock_file
        .plugins
        .iter()
        .filter(|plugin| {
            !config
                .plugins
                .as_ref()
                .unwrap()
                .iter()
                .any(|p| p.get_plugin_repo().is_ok_and(|r| r == plugin.repo))
        })
        .cloned()
        .collect())
}

#[allow(dead_code)]
fn prune<F>(
    force: bool,
    yes: bool,
    confirm_removal: F,
    ctx: &mut PruneContext,
) -> anyhow::Result<()>
where
    F: Fn() -> anyhow::Result<bool>,
{
    info!("{}Checking for unused plugins...", Emoji("🔍 ", ""));

    let remove_plugins: Vec<_> = find_unused_plugins(ctx.config, ctx.lock_file)?;
    if remove_plugins.is_empty() {
        info!(
            "{}No unused plugins found. Your environment is clean!",
            Emoji("🎉 ", "")
        );
        return Ok(());
    }

    if ctx.config.plugins.is_none() {
        warn!(
            "{}{} No plugins are defined in pez.toml.",
            Emoji("🚧 ", ""),
            console::style("Warning:").yellow()
        );
        warn!(
            "{}All plugins defined in pez-lock.toml will be removed.",
            Emoji("🚧 ", "")
        );

        if !yes && !confirm_removal()? {
            anyhow::bail!("{}Prune process aborted.", Emoji("🚧 ", ""));
        }
    }

    for plugin in remove_plugins {
        let repo_path = ctx.data_dir.join(plugin.repo.as_str());
        if repo_path.exists() {
            fs::remove_dir_all(&repo_path)?;
        } else {
            let path_display = repo_path.display();
            warn!(
                "{}{} Repository directory at {} does not exist.",
                Emoji("🚧 ", ""),
                console::style("Warning:").yellow(),
                path_display
            );

            if !force {
                info!(
                    "{}Detected plugin files based on pez-lock.toml:",
                    Emoji("📄 ", ""),
                );

                plugin.files.iter().for_each(|file| {
                    let dest_path = file.get_path(ctx.fish_config_dir);
                    info!("   - {}", dest_path.display());
                });
                info!("If you want to remove these files, use the --force flag.");
                continue;
            }
        }

        info!(
            "{}Removing plugin files based on pez-lock.toml:",
            Emoji("🗑️  ", ""),
        );
        plugin.files.iter().for_each(|file| {
            let dest_path = file.get_path(ctx.fish_config_dir);
            if dest_path.exists() {
                let path_display = dest_path.display();
                info!("   - {}", path_display);
                fs::remove_file(&dest_path).unwrap();
            }
        });
        ctx.lock_file.remove_plugin(&plugin.source);
        ctx.lock_file.save(ctx.lock_file_path)?;
    }
    info!(
        "\n{}All uninstalled plugins have been pruned successfully!",
        Emoji("🎉 ", "")
    );

    Ok(())
}

async fn prune_parallel(force: bool, yes: bool, ctx: &mut PruneContext<'_>) -> anyhow::Result<()> {
    info!("{}Checking for unused plugins...", Emoji("🔍 ", ""));

    let remove_plugins: Vec<_> = find_unused_plugins(ctx.config, ctx.lock_file)?;
    if remove_plugins.is_empty() {
        info!(
            "{}No unused plugins found. Your environment is clean!",
            Emoji("🎉 ", "")
        );
        return Ok(());
    }

    if ctx.config.plugins.is_none() {
        warn!(
            "{}{} No plugins are defined in pez.toml.",
            Emoji("🚧 ", ""),
            console::style("Warning:").yellow()
        );
        warn!(
            "{}All plugins defined in pez-lock.toml will be removed.",
            Emoji("🚧 ", "")
        );

        if !yes && !confirm_removal()? {
            anyhow::bail!("{}Prune process aborted.", Emoji("🚧 ", ""));
        }
    }

    let jobs = utils::load_jobs();
    let fish_config_dir = ctx.fish_config_dir.to_path_buf();
    let data_dir = ctx.data_dir.to_path_buf();

    let tasks = stream::iter(remove_plugins.iter())
        .map(|plugin| {
            let plugin = plugin.clone();
            let fish_config_dir = fish_config_dir.clone();
            let data_dir = data_dir.clone();
            async move {
                let repo_path = data_dir.join(plugin.repo.as_str());
                if repo_path.exists() {
                    tokio::task::spawn_blocking(move || fs::remove_dir_all(&repo_path))
                        .await
                        .unwrap()?;
                } else {
                    let path_display = repo_path.display();
                    warn!(
                        "{}{} Repository directory at {} does not exist.",
                        Emoji("🚧 ", ""),
                        console::style("Warning:").yellow(),
                        path_display
                    );
                    if !force {
                        info!(
                            "{}Detected plugin files based on pez-lock.toml:",
                            Emoji("📄 ", ""),
                        );
                        for file in &plugin.files {
                            let dest_path =
                                fish_config_dir.join(file.dir.as_str()).join(&file.name);
                            info!("   - {}", dest_path.display());
                        }
                        return Ok::<Option<String>, anyhow::Error>(None);
                    }
                }

                info!(
                    "{}Removing plugin files based on pez-lock.toml:",
                    Emoji("🗑️  ", ""),
                );
                for file in &plugin.files {
                    let dest_path = fish_config_dir.join(file.dir.as_str()).join(&file.name);
                    if dest_path.exists() {
                        let to_delete = dest_path.clone();
                        tokio::task::spawn_blocking(move || fs::remove_file(&to_delete))
                            .await
                            .unwrap()
                            .ok();
                    }
                }

                Ok(Some(plugin.source.clone()))
            }
        })
        .buffer_unordered(jobs);

    let mut sources_to_remove: Vec<String> = Vec::new();
    futures::pin_mut!(tasks);
    while let Some(res) = tasks.next().await {
        if let Some(source) = res? {
            sources_to_remove.push(source);
        }
    }

    if !sources_to_remove.is_empty() {
        ctx.lock_file
            .plugins
            .retain(|p| !sources_to_remove.contains(&p.source));
        ctx.lock_file.save(ctx.lock_file_path)?;
    }

    info!(
        "\n{}All uninstalled plugins have been pruned successfully!",
        Emoji("🎉 ", "")
    );
    Ok(())
}

fn dry_run(force: bool, ctx: &mut PruneContext) -> anyhow::Result<()> {
    if ctx.config.plugins.is_none() {
        warn!(
            "{}{} No plugins are defined in pez.toml.",
            Emoji("🚧 ", ""),
            console::style("Warning:").yellow()
        );
        warn!(
            "{}All plugins defined in pez-lock.toml will be removed.",
            Emoji("🚧 ", "")
        );
    }

    let remove_plugins: Vec<_> = if ctx.config.plugins.is_none() {
        ctx.lock_file.plugins.clone()
    } else {
        ctx.lock_file
            .plugins
            .iter()
            .filter(|plugin| {
                !ctx.config
                    .plugins
                    .as_ref()
                    .unwrap()
                    .iter()
                    .any(|p| p.get_plugin_repo().is_ok_and(|r| r == plugin.repo))
            })
            .cloned()
            .collect()
    };

    info!("{}Plugins that would be removed:", Emoji("🐟 ", ""));
    remove_plugins.iter().for_each(|plugin| {
        info!("  - {}", &plugin.repo);
    });

    for plugin in remove_plugins {
        let repo_path = ctx.data_dir.join(plugin.repo.as_str());
        if !repo_path.exists() {
            let path_display = repo_path.display();
            warn!(
                "{}{} Repository directory at {} does not exist.",
                Emoji("🚧 ", ""),
                console::style("Warning:").yellow(),
                path_display
            );

            if !force {
                info!(
                    "{}Detected plugin files based on pez-lock.toml:",
                    Emoji("📄 ", ""),
                );

                plugin.files.iter().for_each(|file| {
                    let dest_path = file.get_path(ctx.fish_config_dir);
                    info!("   - {}", dest_path.display());
                });
                info!("If you want to remove these files, use the --force flag.");
                continue;
            }
        }

        info!(
            "{}Plugin files that would be removed based on pez-lock.toml:",
            Emoji("🗑️  ", ""),
        );
        plugin.files.iter().for_each(|file| {
            let dest_path = file.get_path(ctx.fish_config_dir);
            if dest_path.exists() {
                let path_display = dest_path.display();
                info!("   - {}", path_display);
            }
        });
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::vec;

    use super::*;
    use crate::{
        lock_file::{self, PluginFile},
        models::PluginRepo,
        models::TargetDir,
        tests_support::env::TestEnvironmentSetup,
    };
    use config::{PluginSource, PluginSpec};

    struct TestDataBuilder {
        used_plugin: Plugin,
        unused_plugin: Plugin,
        used_plugin_spec: PluginSpec,
    }

    impl TestDataBuilder {
        fn new() -> Self {
            Self {
                used_plugin: Plugin {
                    name: "used-repo".to_string(),
                    repo: PluginRepo {
                        owner: "owner".to_string(),
                        repo: "used-repo".to_string(),
                    },
                    source: "https://example.com/owner/used-repo".to_string(),
                    commit_sha: "sha".to_string(),
                    files: vec![PluginFile {
                        dir: TargetDir::Functions,
                        name: "used.fish".to_string(),
                    }],
                },
                unused_plugin: Plugin {
                    name: "unused-repo".to_string(),
                    repo: PluginRepo {
                        owner: "owner".to_string(),
                        repo: "unused-repo".to_string(),
                    },
                    source: "https://example.com/owner/unused-repo".to_string(),
                    commit_sha: "sha".to_string(),
                    files: vec![PluginFile {
                        dir: TargetDir::Functions,
                        name: "unused.fish".to_string(),
                    }],
                },
                used_plugin_spec: PluginSpec {
                    name: None,
                    source: PluginSource::Repo {
                        repo: PluginRepo {
                            owner: "owner".to_string(),
                            repo: "used-repo".to_string(),
                        },
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                },
            }
        }
        fn build(self) -> TestData {
            TestData {
                used_plugin: self.used_plugin,
                unused_plugin: self.unused_plugin,
                used_plugin_spec: self.used_plugin_spec,
            }
        }
    }

    struct TestData {
        used_plugin: Plugin,
        unused_plugin: Plugin,
        used_plugin_spec: PluginSpec,
    }

    impl TestEnvironmentSetup {
        fn create_context<'a>(&'a mut self) -> PruneContext<'a> {
            PruneContext {
                fish_config_dir: &self.fish_config_dir,
                data_dir: &self.data_dir,
                config: self.config.as_ref().expect("Config is not initialized"),
                lock_file: self
                    .lock_file
                    .as_mut()
                    .expect("Lock file is not initialized"),
                lock_file_path: &self.lock_file_path,
            }
        }
    }

    #[test]
    fn test_find_unused_plugins() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin, test_data.unused_plugin],
        });
        let ctx = test_env.create_context();

        let result = find_unused_plugins(ctx.config, ctx.lock_file);
        assert!(result.is_ok());

        let unused_plugins = result.unwrap();
        assert_eq!(unused_plugins.len(), 1, "Only one plugin should be unused");
        assert_eq!(
            unused_plugins[0].repo.as_str(),
            "owner/unused-repo",
            "owner/unused-repo should be unused"
        );
    }

    #[test]
    fn test_prune() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin, test_data.unused_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();

        let result = prune(false, false, || Ok(false), &mut ctx);
        assert!(result.is_ok());

        let saved_lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(
            saved_lock_file.plugins.len(),
            1,
            "Only one plugin should remain"
        );
        assert_eq!(
            saved_lock_file.plugins[0].repo.as_str(),
            "owner/used-repo",
            "owner/used-repo should remain"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/unused-repo")).is_err(),
            "Unused repo directory should be deleted"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/used-repo")).is_ok(),
            "Used repo directory should still exist"
        );
    }

    #[test]
    fn test_prune_empty_remove_plugins() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();
        let prev_plugins_len = ctx.lock_file.plugins.len();

        let result = prune(false, false, || Ok(false), &mut ctx);
        assert!(result.is_ok());

        let saved_lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(
            saved_lock_file.plugins.len(),
            prev_plugins_len,
            "No plugins should be removed"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/used-repo")).is_ok(),
            "Used repo directory should still exist"
        );
    }

    #[test]
    fn test_prune_empty_config_without_yes_and_confirm_removal_true() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config { plugins: None });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.unused_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();

        let result = prune(false, false, || Ok(true), &mut ctx);
        assert!(result.is_ok());

        let lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(lock_file.plugins.len(), 0, "All plugins should be removed");
        assert!(
            fs::metadata(ctx.data_dir.join("owner/unused-repo")).is_err(),
            "Unused repo directory should be deleted"
        );
    }

    #[test]
    fn test_prune_empty_config_without_yes_and_confirm_removal_false() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config { plugins: None });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.unused_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();
        let prev_plugins_len = ctx.lock_file.plugins.len();

        let result = prune(false, false, || Ok(false), &mut ctx);
        assert!(result.is_err_and(|e| e.to_string().contains("Prune process aborted.")));

        let lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(
            lock_file.plugins.len(),
            prev_plugins_len,
            "No plugins should be removed"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/unused-repo")).is_ok(),
            "Unused repo directory should still exist"
        );
    }

    #[test]
    fn test_prune_empty_config_with_yes() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config { plugins: None });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.unused_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();

        let result = prune(false, true, || Ok(false), &mut ctx);
        assert!(result.is_ok());

        let lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(lock_file.plugins.len(), 0, "All plugins should be removed");
        assert!(
            fs::metadata(ctx.data_dir.join("owner/unused-repo")).is_err(),
            "Unused repo directory should be deleted"
        );
    }

    #[test]
    fn test_prune_empty_config_missing_data_dir_with_force() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin, test_data.unused_plugin],
        });
        test_env.setup_fish_config();
        assert!(
            fs::metadata(test_env.fish_config_dir.join("functions/unused.fish")).is_ok(),
            "Unused plugin file should exist"
        );

        let mut ctx = test_env.create_context();

        let result = prune(true, false, || Ok(false), &mut ctx);
        assert!(result.is_ok());

        let lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(
            lock_file.plugins.len(),
            1,
            "Unused plugin should be removed"
        );
        assert!(
            fs::metadata(test_env.fish_config_dir.join("functions/unused.fish")).is_err(),
            "Unused plugin file should be deleted"
        );
    }

    #[test]
    fn test_prune_empty_config_missing_data_dir_without_force() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin, test_data.unused_plugin],
        });
        test_env.setup_fish_config();

        let mut ctx = test_env.create_context();

        let result = prune(false, false, || Ok(false), &mut ctx);
        assert!(result.is_ok());

        let lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(lock_file.plugins.len(), 2, "No plugins should be removed");
        assert!(
            fs::metadata(test_env.fish_config_dir.join("functions/unused.fish")).is_ok(),
            "Unused plugin file should still exist"
        );
    }

    #[test]
    fn test_prune_dry_run() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.used_plugin_spec]),
        });
        test_env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![test_data.used_plugin, test_data.unused_plugin],
        });
        test_env.setup_data_repo(test_env.lock_file.as_ref().unwrap().get_plugin_repos());

        let mut ctx = test_env.create_context();

        let result = dry_run(false, &mut ctx);
        assert!(result.is_ok());

        let saved_lock_file = lock_file::load(ctx.lock_file_path).unwrap();
        assert_eq!(
            saved_lock_file.plugins.len(),
            2,
            "No plugins should be removed"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/unused-repo")).is_ok(),
            "Unused repo directory should still exist"
        );
        assert!(
            fs::metadata(ctx.data_dir.join("owner/used-repo")).is_ok(),
            "Used repo directory should still exist"
        );
    }
}
</file>

<file path="src/config.rs">
use serde_derive::{Deserialize, Serialize};
use std::{fs, path};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct Config {
    pub(crate) plugins: Option<Vec<PluginSpec>>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct PluginSpec {
    pub(crate) name: Option<String>,
    #[serde(flatten)]
    pub(crate) source: PluginSource,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(untagged)]
pub(crate) enum PluginSource {
    // GitHub shorthand: { repo = "owner/repo", [version|branch|tag|commit] = "..." }
    Repo {
        repo: crate::models::PluginRepo,
        #[serde(default)]
        version: Option<String>,
        #[serde(default)]
        branch: Option<String>,
        #[serde(default)]
        tag: Option<String>,
        #[serde(default)]
        commit: Option<String>,
    },
    // Generic Git: { url = "https://host/owner/repo", [version|branch|tag|commit] = "..." }
    Url {
        url: String,
        #[serde(default)]
        version: Option<String>,
        #[serde(default)]
        branch: Option<String>,
        #[serde(default)]
        tag: Option<String>,
        #[serde(default)]
        commit: Option<String>,
    },
    // Local path: { path = "~/plugins/foo" }
    Path {
        path: String,
    },
}

pub(crate) fn init() -> Config {
    Config { plugins: None }
}

pub(crate) fn load(path: &path::PathBuf) -> anyhow::Result<Config> {
    let content = fs::read_to_string(path)?;
    let config = toml::from_str(&content)?;

    Ok(config)
}

impl Config {
    pub(crate) fn save(&self, path: &path::PathBuf) -> anyhow::Result<()> {
        let contents = toml::to_string(self)?;
        fs::write(path, contents)?;

        Ok(())
    }
}

impl PluginSpec {
    pub(crate) fn get_name(&self) -> anyhow::Result<String> {
        if let Some(name) = &self.name {
            return Ok(name.clone());
        }
        let repo = self.get_plugin_repo()?;
        Ok(repo.repo)
    }

    /// Derive a PluginRepo (owner/repo) for use as a stable identifier and data dir name.
    /// - Github: uses provided owner/repo
    /// - Git URL: attempts to parse last two path segments as owner/repo
    /// - Path: owner = "local", repo = basename of path
    pub(crate) fn get_plugin_repo(&self) -> anyhow::Result<crate::models::PluginRepo> {
        match &self.source {
            PluginSource::Repo { repo, .. } => Ok(repo.clone()),
            PluginSource::Url { url, .. } => {
                // Parse last two segments from URL path
                let repo_name = url
                    .trim_end_matches('/')
                    .trim_end_matches(".git")
                    .rsplit('/')
                    .next()
                    .unwrap_or("repo")
                    .to_string();
                let owner = url
                    .trim_end_matches('/')
                    .rsplit('/')
                    .nth(1)
                    .unwrap_or("owner")
                    .to_string();
                Ok(crate::models::PluginRepo {
                    owner,
                    repo: repo_name,
                })
            }
            PluginSource::Path { path } => {
                let expanded = expand_tilde(path)?;
                let name = std::path::Path::new(&expanded)
                    .file_name()
                    .and_then(|s| s.to_str())
                    .ok_or_else(|| anyhow::anyhow!("Invalid local path: {expanded}"))?
                    .to_string();
                Ok(crate::models::PluginRepo {
                    owner: "local".to_string(),
                    repo: name,
                })
            }
        }
    }

    /// Convert to a ResolvedInstallTarget for installation flows.
    pub(crate) fn to_resolved(&self) -> anyhow::Result<crate::models::ResolvedInstallTarget> {
        let plugin_repo = self.get_plugin_repo()?;
        match &self.source {
            PluginSource::Repo {
                repo: _,
                version,
                branch,
                tag,
                commit,
            } => {
                let src = format!("https://github.com/{}", plugin_repo.as_str());
                let refspec = pick_single_ref(version, branch, tag, commit)?;
                Ok(crate::models::ResolvedInstallTarget {
                    plugin_repo,
                    source: src,
                    ref_kind: crate::resolver::RefKind::from(refspec),
                    is_local: false,
                })
            }
            PluginSource::Url {
                url,
                version,
                branch,
                tag,
                commit,
            } => {
                let mut normalized = url.clone();
                if !normalized.contains("://") {
                    normalized = format!("https://{normalized}");
                }
                let refspec = pick_single_ref(version, branch, tag, commit)?;
                Ok(crate::models::ResolvedInstallTarget {
                    plugin_repo,
                    source: normalized,
                    ref_kind: crate::resolver::RefKind::from(refspec),
                    is_local: false,
                })
            }
            PluginSource::Path { path } => {
                let expanded = expand_tilde(path)?;
                if !expanded.starts_with('/') {
                    anyhow::bail!(
                        "path must be absolute or start with ~/ (after expansion must be absolute)"
                    );
                }
                Ok(crate::models::ResolvedInstallTarget {
                    plugin_repo,
                    source: expanded,
                    ref_kind: crate::resolver::RefKind::None,
                    is_local: true,
                })
            }
        }
    }
}

#[cfg(test)]
mod internal_tests {
    use super::*;

    #[test]
    fn repo_to_resolved_latest() {
        let s = PluginSource::Repo {
            repo: crate::models::PluginRepo {
                owner: "o".into(),
                repo: "r".into(),
            },
            version: Some("latest".into()),
            branch: None,
            tag: None,
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let r = spec.to_resolved().unwrap();
        assert_eq!(r.source, "https://github.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::Latest);
    }

    #[test]
    fn url_without_scheme_normalizes() {
        let s = PluginSource::Url {
            url: "gitlab.com/o/r".into(),
            version: Some("v3".into()),
            branch: None,
            tag: None,
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let r = spec.to_resolved().unwrap();
        assert_eq!(r.source, "https://gitlab.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::Version(_));
    }

    #[test]
    fn path_requires_absolute_or_tilde() {
        let s = PluginSource::Path {
            path: "relative/path".into(),
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let err = spec.to_resolved().unwrap_err();
        assert!(err.to_string().contains("absolute"));
    }

    #[test]
    fn one_of_rule_enforced() {
        let s = PluginSource::Repo {
            repo: crate::models::PluginRepo {
                owner: "o".into(),
                repo: "r".into(),
            },
            version: Some("v1".into()),
            branch: None,
            tag: Some("v1.0.0".into()),
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let err = spec.to_resolved().unwrap_err();
        assert!(err.to_string().contains("Multiple version selectors"));
    }
}
fn expand_tilde(p: &str) -> anyhow::Result<String> {
    if let Some(stripped) = p.strip_prefix("~/") {
        let home = std::env::var_os("HOME").ok_or_else(|| anyhow::anyhow!("HOME not set"))?;
        Ok(std::path::Path::new(&home)
            .join(stripped)
            .to_string_lossy()
            .to_string())
    } else if p == "~" {
        let home = std::env::var_os("HOME").ok_or_else(|| anyhow::anyhow!("HOME not set"))?;
        Ok(std::path::PathBuf::from(home).to_string_lossy().to_string())
    } else {
        Ok(p.to_string())
    }
}

fn pick_single_ref(
    version: &Option<String>,
    branch: &Option<String>,
    tag: &Option<String>,
    commit: &Option<String>,
) -> anyhow::Result<Option<String>> {
    let mut vals = vec![];
    if let Some(v) = version {
        vals.push(("version", v.clone()));
    }
    if let Some(v) = branch {
        vals.push(("branch", v.clone()));
    }
    if let Some(v) = tag {
        vals.push(("tag", v.clone()));
    }
    if let Some(v) = commit {
        vals.push(("commit", v.clone()));
    }
    if vals.len() > 1 {
        let kinds = vals.iter().map(|(k, _)| *k).collect::<Vec<_>>().join(", ");
        anyhow::bail!(format!(
            "Multiple version selectors set: {kinds}. Please specify only one of version, branch, tag, or commit."
        ));
    }
    Ok(vals.into_iter().next().map(|(_, v)| v))
}

impl From<Option<String>> for crate::resolver::RefKind {
    fn from(val: Option<String>) -> Self {
        match val {
            None => crate::resolver::RefKind::None,
            Some(x) => {
                if x.eq_ignore_ascii_case("latest") {
                    crate::resolver::RefKind::Latest
                } else {
                    crate::resolver::RefKind::Version(x)
                }
            }
        }
    }
}

use crate::resolver::RefKind;

#[allow(dead_code)]
fn ref_to_kind(val: Option<String>) -> RefKind {
    match val {
        None => RefKind::None,
        Some(x) => {
            if x.eq_ignore_ascii_case("latest") {
                return RefKind::Latest;
            }
            RefKind::Version(x)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn repo_to_resolved_latest() {
        let s = PluginSource::Repo {
            repo: crate::models::PluginRepo {
                owner: "o".into(),
                repo: "r".into(),
            },
            version: Some("latest".into()),
            branch: None,
            tag: None,
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let r = spec.to_resolved().unwrap();
        assert_eq!(r.source, "https://github.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::Latest);
    }

    #[test]
    fn url_without_scheme_normalizes() {
        let s = PluginSource::Url {
            url: "gitlab.com/o/r".into(),
            version: Some("v3".into()),
            branch: None,
            tag: None,
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let r = spec.to_resolved().unwrap();
        assert_eq!(r.source, "https://gitlab.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::Version(_));
    }

    #[test]
    fn path_requires_absolute_or_tilde() {
        let s = PluginSource::Path {
            path: "relative/path".into(),
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let err = spec.to_resolved().unwrap_err();
        assert!(err.to_string().contains("absolute"));
    }

    #[test]
    fn one_of_rule_enforced() {
        let s = PluginSource::Repo {
            repo: crate::models::PluginRepo {
                owner: "o".into(),
                repo: "r".into(),
            },
            version: Some("v1".into()),
            branch: None,
            tag: Some("v1.0.0".into()),
            commit: None,
        };
        let spec = PluginSpec {
            name: None,
            source: s,
        };
        let err = spec.to_resolved().unwrap_err();
        assert!(err.to_string().contains("Multiple version selectors"));
    }
}
</file>

<file path="src/lock_file.rs">
use crate::{models::PluginRepo, models::TargetDir};

use serde_derive::{Deserialize, Serialize};
use std::{fs, path};
use tracing::error;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct LockFile {
    pub(crate) version: u32,
    pub(crate) plugins: Vec<Plugin>,
}

pub(crate) fn init() -> LockFile {
    LockFile {
        version: 1,
        plugins: vec![],
    }
}

pub(crate) fn load(path: &path::Path) -> anyhow::Result<LockFile> {
    let content = fs::read_to_string(path)?;
    let lock_file = toml::from_str(&content)?;

    Ok(lock_file)
}

impl LockFile {
    pub(crate) fn save(&self, path: &path::Path) -> anyhow::Result<()> {
        let contents = toml::to_string(self)?;
        fs::write(path, AUTO_GENERATED_COMMENT.to_string() + &contents)?;

        Ok(())
    }

    pub(crate) fn add_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self
            .plugins
            .iter()
            .any(|p| p.source == plugin.source || p.name == plugin.name)
        {
            error!(
                "Plugin already exists: name={}, source={}",
                plugin.name, plugin.source
            );
            anyhow::bail!(
                "Plugin already exists: name={}, source={}",
                plugin.name,
                plugin.source
            );
        }
        self.plugins.push(plugin);
        Ok(())
    }

    pub(crate) fn remove_plugin(&mut self, source: &str) {
        self.plugins.retain(|p| p.source != source);
    }

    pub(crate) fn get_plugin_by_repo(&self, repo: &PluginRepo) -> Option<&Plugin> {
        self.plugins.iter().find(|p| &p.repo == repo)
    }

    pub(crate) fn update_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        self.remove_plugin(&plugin.source);
        self.add_plugin(plugin)?;
        Ok(())
    }

    pub(crate) fn merge_plugins(&mut self, new_plugins: Vec<Plugin>) {
        for new_plugin in new_plugins {
            let source = new_plugin.source.clone();
            if let Some(plugin) = self.plugins.iter_mut().find(|p| p.source == source) {
                *plugin = new_plugin;
            } else {
                self.plugins.push(new_plugin);
            }
        }
    }

    /// Returns true if a plugin with the given repo exists.
    pub(crate) fn contains_repo(&self, repo: &PluginRepo) -> bool {
        self.plugins.iter().any(|p| &p.repo == repo)
    }

    /// Upsert a plugin by repo (or source) semantics. If repo exists, update; otherwise add.
    pub(crate) fn upsert_plugin_by_repo(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self.contains_repo(&plugin.repo) {
            self.update_plugin(plugin)
        } else {
            self.add_plugin(plugin)
        }
    }
}

pub(crate) const AUTO_GENERATED_COMMENT: &str =
    "# This file is automatically generated by pez. Do not edit it manually.\n";

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct Plugin {
    pub(crate) name: String,
    pub(crate) repo: PluginRepo,
    pub(crate) source: String,
    pub(crate) commit_sha: String,
    pub(crate) files: Vec<PluginFile>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub(crate) struct PluginFile {
    pub(crate) dir: TargetDir,
    pub(crate) name: String,
}

impl Plugin {
    pub(crate) fn get_name(&self) -> String {
        if self.name.is_empty() {
            let parts: Vec<&str> = self.source.split("/").collect();
            parts[parts.len() - 1].to_owned()
        } else {
            self.name.clone()
        }
    }
}

impl PluginFile {
    pub(crate) fn get_path(&self, config_dir: &path::Path) -> path::PathBuf {
        config_dir.join(self.dir.as_str()).join(&self.name)
    }
}
</file>

<file path="src/resolver.rs">
use crate::config::PluginSource;

use crate::models::PluginRepo;

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum RefKind {
    None,
    Latest,
    Version(String),
    Tag(String),
    Branch(String),
    Commit(String),
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum Selection {
    DefaultHead,
    Latest,
    Branch(String),
    Tag(String),
    Commit(String),
    Version(String),
}

pub(crate) fn parse_ref_kind(s: &str) -> RefKind {
    if s.eq_ignore_ascii_case("latest") {
        return RefKind::Latest;
    }
    if let Some(rest) = s.strip_prefix("tag:") {
        return RefKind::Tag(rest.to_string());
    }
    if let Some(rest) = s.strip_prefix("branch:") {
        return RefKind::Branch(rest.to_string());
    }
    if let Some(rest) = s.strip_prefix("commit:") {
        return RefKind::Commit(rest.to_string());
    }
    if let Some(rest) = s.strip_prefix("version:") {
        return RefKind::Version(rest.to_string());
    }
    RefKind::Version(s.to_string())
}

pub(crate) fn selection_from_ref_kind(kind: &RefKind) -> Selection {
    match kind {
        RefKind::None => Selection::DefaultHead,
        RefKind::Latest => Selection::Latest,
        RefKind::Version(v) => Selection::Version(v.clone()),
        RefKind::Tag(t) => Selection::Tag(t.clone()),
        RefKind::Branch(b) => Selection::Branch(b.clone()),
        RefKind::Commit(c) => Selection::Commit(c.clone()),
    }
}

pub(crate) fn ref_kind_to_repo_source(repo: &PluginRepo, kind: &RefKind) -> PluginSource {
    match kind {
        RefKind::None => PluginSource::Repo {
            repo: repo.clone(),
            version: None,
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Latest => PluginSource::Repo {
            repo: repo.clone(),
            version: Some("latest".to_string()),
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Version(v) => PluginSource::Repo {
            repo: repo.clone(),
            version: Some(v.clone()),
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Tag(t) => PluginSource::Repo {
            repo: repo.clone(),
            version: None,
            branch: None,
            tag: Some(t.clone()),
            commit: None,
        },
        RefKind::Branch(b) => PluginSource::Repo {
            repo: repo.clone(),
            version: None,
            branch: Some(b.clone()),
            tag: None,
            commit: None,
        },
        RefKind::Commit(c) => PluginSource::Repo {
            repo: repo.clone(),
            version: None,
            branch: None,
            tag: None,
            commit: Some(c.clone()),
        },
    }
}

pub(crate) fn ref_kind_to_url_source(url: &str, kind: &RefKind) -> PluginSource {
    match kind {
        RefKind::None => PluginSource::Url {
            url: url.to_string(),
            version: None,
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Latest => PluginSource::Url {
            url: url.to_string(),
            version: Some("latest".to_string()),
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Version(v) => PluginSource::Url {
            url: url.to_string(),
            version: Some(v.clone()),
            branch: None,
            tag: None,
            commit: None,
        },
        RefKind::Tag(t) => PluginSource::Url {
            url: url.to_string(),
            version: None,
            branch: None,
            tag: Some(t.clone()),
            commit: None,
        },
        RefKind::Branch(b) => PluginSource::Url {
            url: url.to_string(),
            version: None,
            branch: Some(b.clone()),
            tag: None,
            commit: None,
        },
        RefKind::Commit(c) => PluginSource::Url {
            url: url.to_string(),
            version: None,
            branch: None,
            tag: None,
            commit: Some(c.clone()),
        },
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parses_ref_kinds() {
        assert!(matches!(parse_ref_kind("latest"), RefKind::Latest));
        assert!(matches!(parse_ref_kind("tag:v1.0.0"), RefKind::Tag(t) if t=="v1.0.0"));
        assert!(matches!(parse_ref_kind("branch:dev"), RefKind::Branch(b) if b=="dev"));
        assert!(matches!(parse_ref_kind("commit:abc1234"), RefKind::Commit(c) if c=="abc1234"));
        assert!(matches!(parse_ref_kind("version:v3"), RefKind::Version(v) if v=="v3"));
        assert!(matches!(parse_ref_kind("v3"), RefKind::Version(v) if v=="v3"));
    }

    #[test]
    fn maps_to_selection() {
        let sel = selection_from_ref_kind(&RefKind::Latest);
        match sel {
            Selection::Latest => {}
            _ => panic!(),
        }
        let sel = selection_from_ref_kind(&RefKind::Branch("main".into()));
        match sel {
            Selection::Branch(b) => assert_eq!(b, "main"),
            _ => panic!(),
        }
        let sel = selection_from_ref_kind(&RefKind::Tag("v1".into()));
        match sel {
            Selection::Tag(t) => assert_eq!(t, "v1"),
            _ => panic!(),
        }
        let sel = selection_from_ref_kind(&RefKind::Commit("abc".into()));
        match sel {
            Selection::Commit(c) => assert_eq!(c, "abc"),
            _ => panic!(),
        }
        let sel = selection_from_ref_kind(&RefKind::Version("v3".into()));
        match sel {
            Selection::Version(v) => assert_eq!(v, "v3"),
            _ => panic!(),
        }
    }
}
</file>

<file path="src/cmd/uninstall.rs">
use crate::{cli::UninstallArgs, models::PluginRepo, models::TargetDir, utils};

use console::Emoji;
use futures::{StreamExt, stream};
use std::fs;
use tracing::{error, info, warn};

pub(crate) async fn run(args: &UninstallArgs) -> anyhow::Result<()> {
    info!("{}Starting uninstallation process...", Emoji("🔍 ", ""));
    let jobs = utils::load_jobs();
    let plugins: Vec<PluginRepo> = args.plugins.clone().unwrap_or_default();
    if plugins.is_empty() {
        anyhow::bail!("No plugins specified for uninstall");
    }
    let tasks = stream::iter(plugins.iter())
        .map(|plugin| {
            let plugin = plugin.clone();
            let force = args.force;
            tokio::task::spawn_blocking(move || {
                info!("\n{}Uninstalling plugin: {}", Emoji("✨ ", ""), plugin);
                uninstall(&plugin, force)
            })
        })
        .buffer_unordered(jobs);

    let results: Vec<_> = tasks.collect().await;
    for r in results {
        r??;
    }
    info!(
        "\n{}All specified plugins have been uninstalled successfully!",
        Emoji("🎉 ", "")
    );

    Ok(())
}

#[allow(dead_code)]
fn read_plugins_from_stdin() -> anyhow::Result<Vec<PluginRepo>> {
    use std::io::{self, Read};
    let mut buf = String::new();
    io::stdin().read_to_string(&mut buf)?;
    let mut out = Vec::new();
    for line in buf.lines() {
        let s = line.trim();
        if s.is_empty() || s.starts_with('#') {
            continue;
        }
        match s.parse::<PluginRepo>() {
            Ok(p) => out.push(p),
            Err(_) => warn!("{}Skipping unrecognized entry: {}", Emoji("⚠ ", ""), s),
        }
    }
    out.sort_by_key(|a| a.as_str());
    out.dedup_by(|a, b| a.as_str() == b.as_str());
    Ok(out)
}

pub(crate) fn uninstall(plugin_repo: &PluginRepo, force: bool) -> anyhow::Result<()> {
    let plugin_repo_str = plugin_repo.as_str();
    let config_dir = utils::load_fish_config_dir()?;

    let (mut config, config_path) = utils::load_or_create_config()?;
    let repo_path = utils::load_pez_data_dir()?.join(&plugin_repo_str);
    let (mut lock_file, lock_file_path) = utils::load_or_create_lock_file()?;
    match lock_file.get_plugin_by_repo(plugin_repo) {
        Some(locked_plugin) => {
            let locked = locked_plugin.clone();
            locked
                .files
                .iter()
                .filter(|f| f.dir == TargetDir::ConfD)
                .for_each(|f| {
                    let _ = utils::emit_event(&f.name, &utils::Event::Uninstall);
                });

            if repo_path.exists() {
                fs::remove_dir_all(&repo_path)?;
            } else {
                let path_display = repo_path.display();
                warn!(
                    "{}{} Repository directory at {} does not exist.",
                    Emoji("🚧 ", ""),
                    console::style("Warning:").yellow(),
                    path_display
                );
                if !force {
                    info!(
                        "{}Detected plugin files based on pez-lock.toml:",
                        Emoji("📄 ", ""),
                    );
                    locked.files.iter().for_each(|file| {
                        let dest_path = config_dir.join(file.dir.as_str()).join(&file.name);
                        info!("   - {}", dest_path.display());
                    });
                    error!("If you want to remove these files, use the --force flag.");
                    anyhow::bail!(
                        "Repository directory does not exist. Use --force to remove files listed in lock file"
                    );
                }
            }

            info!(
                "{}Removing plugin files based on pez-lock.toml:",
                Emoji("🗑️  ", ""),
            );
            locked.files.iter().for_each(|file| {
                let dest_path = config_dir.join(file.dir.as_str()).join(&file.name);
                if dest_path.exists() {
                    let path_display = dest_path.display();
                    info!("   - {}", path_display);
                    fs::remove_file(&dest_path).unwrap();
                }
            });
            lock_file.remove_plugin(&locked.source);
            lock_file.save(&lock_file_path)?;

            if let Some(ref mut plugin_specs) = config.plugins {
                plugin_specs.retain(|p| p.get_plugin_repo().map_or(true, |r| r != *plugin_repo));
                config.save(&config_path)?;
            }
        }
        None => {
            error!(
                "{}{} Plugin {} is not installed.",
                Emoji("❌ ", ""),
                console::style("Error:").red().bold(),
                plugin_repo_str
            );
            anyhow::bail!("Plugin is not installed: {}", plugin_repo_str);
        }
    }
    info!(
        "{}Successfully uninstalled: {}",
        Emoji("✅ ", ""),
        plugin_repo_str
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config;
    use crate::lock_file::{self, LockFile, PluginFile};
    use crate::tests_support::env::TestEnvironmentSetup;

    #[test]
    fn test_uninstall_removes_repo_and_files_and_updates_lock_and_config() {
        // Setup isolated test environment
        let mut env = TestEnvironmentSetup::new();

        // Ensure pez uses our isolated dirs
        unsafe {
            std::env::set_var("__fish_config_dir", &env.fish_config_dir);
            std::env::set_var("PEZ_CONFIG_DIR", &env.config_dir);
            std::env::set_var("PEZ_DATA_DIR", &env.data_dir);
        }

        // Create config with one plugin spec
        let repo = PluginRepo {
            owner: "owner".into(),
            repo: "pkg".into(),
        };
        let spec = config::PluginSpec {
            name: None,
            source: config::PluginSource::Repo {
                repo: repo.clone(),
                version: None,
                branch: None,
                tag: None,
                commit: None,
            },
        };
        env.setup_config(config::Config {
            plugins: Some(vec![spec]),
        });

        // Create repo dir and a file record in lockfile that points to a functions file
        env.setup_data_repo(vec![repo.clone()]);
        let functions_dir = env.fish_config_dir.join(TargetDir::Functions.as_str());
        std::fs::create_dir_all(&functions_dir).unwrap();
        let dest_file = functions_dir.join("hello.fish");
        std::fs::File::create(&dest_file).unwrap();

        let plugin = crate::lock_file::Plugin {
            name: "pkg".into(),
            repo: repo.clone(),
            source: format!("https://github.com/{}", repo.as_str()),
            commit_sha: "abc1234".into(),
            files: vec![PluginFile {
                dir: TargetDir::Functions,
                name: "hello.fish".into(),
            }],
        };
        env.setup_lock_file(LockFile {
            version: 1,
            plugins: vec![plugin],
        });

        // Act: uninstall with --force (true)
        let res = uninstall(&repo, true);
        assert!(res.is_ok());

        // Assert: repo directory removed
        assert!(std::fs::metadata(env.data_dir.join(repo.as_str())).is_err());
        // Assert: destination file removed
        assert!(std::fs::metadata(&dest_file).is_err());
        // Assert: lock file updated (plugin removed)
        let lock = lock_file::load(&env.lock_file_path).unwrap();
        assert!(lock.plugins.is_empty());
        // Assert: config updated (plugin spec removed)
        let cfg = config::load(&env.config_path).unwrap();
        assert!(
            cfg.plugins
                .unwrap()
                .into_iter()
                .all(|p| p.get_plugin_repo().unwrap() != repo)
        );
    }
}
</file>

<file path="README.md">
<h1 align="center">pez</h1>

<p align="center"><strong>A Rust-based plugin manager for <a href="https://fishshell.com/">fish</a></strong></p>

<p align="center">
  <em>Experimental</em> — use at your own risk.
</p>

## Installation

Ensure you have Rust installed on your system. You can install pez using Cargo:

```sh
# From crates.io (if available)
cargo install pez

# From source (in this repo)
cargo install --path .
```

## Quickstart

```fish
# 1) Initialize configuration (creates pez.toml)
pez init

# 2) Add a plugin to pez.toml (choose one of repo/url/path)
#    [[plugins]]
#    repo = "owner/repo"      # GitHub shorthand
#    # version = "v3"        # Or: tag = "...", branch = "...", commit = "..."
#
#    # [[plugins]]
#    # url = "https://gitlab.com/owner/repo"  # Any Git host URL
#    # branch = "main"
#
#    # [[plugins]]
#    # path = "~/path/to/local/plugin"       # Local directory (absolute or ~/ only)
#    # Note: when specifying a relative path at the CLI (e.g., ./plugin), pez normalizes it to an absolute path in pez.toml.

# 3) Install plugins listed in pez.toml
pez install

# 4) Verify installation
pez list --format table

# 5) (Optional) Enable completions for pez itself
pez completions fish > ~/.config/fish/completions/pez.fish
```

## Shell Completions

```fish
pez completions fish > ~/.config/fish/completions/pez.fish
```

## Docs & FAQ

- [Getting started](docs/getting-started.md)
  - [CLI usage](docs/getting-started.md#cli-usage-examples)
  - [Completions](docs/getting-started.md#quick-start)
- [Command reference](docs/commands.md)
- [Configuration](docs/configuration.md)
- [Architecture](docs/architecture.md)
- [Install & build](docs/install.md)
- [FAQ](docs/faq.md)

## Usage (overview)

```fish
Usage: pez [OPTIONS] <COMMAND>

Commands:
  init | install | uninstall | upgrade | list | prune | completions | doctor | migrate

Options:
  -v, --verbose  Increase output verbosity (-v for info, -vv for debug)
  -h, --help     Print help
  -V, --version  Print version
```

Common examples

```fish
pez init
pez install                 # install from pez.toml
pez install owner/repo      # install a specific plugin
pez upgrade                 # update non-local plugins to remote HEAD
pez list --outdated --format table
pez prune --dry-run
```

See the full command reference in [docs/commands.md](docs/commands.md).

## Configuration

pez uses two main configuration files: `pez.toml` and `pez-lock.toml.`
By default, these files are created in the fish configuration directory,
but you can specify a different location using environment variables.

Configuration File Locations

The configuration files are located based on the following priority:
`$PEZ_CONFIG_DIR` > `$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

### pez.toml (Schema)

`pez.toml` is the primary configuration file where you define the plugins
you want to manage. Below is an example structure:

```toml
# GitHub shorthand
[[plugins]]
repo = "owner/repo"
# version = "latest"   # default if omitted
# version = "v3"       # branch or tag name; branches preferred over tags
# branch  = "develop"
# tag     = "v1.0.0"
# commit  = "<sha>"    # 7+ chars recommended (unique per repo)

# Generic Git host URL
[[plugins]]
url = "https://gitlab.com/owner/repo"
# branch = "main"

# Local path (absolute or ~/ only)
[[plugins]]
path = "~/path/to/local/plugin"
```

### pez-lock.toml

`pez-lock.toml` is automatically generated and maintained by pez.
It records detailed information about the installed plugins,
including their source repositories and specific commit SHAs.
Do not edit this file manually.

## Data Directory

pez clones plugin repositories into a designated data directory,
prioritized as follows:
`$PEZ_DATA_DIR` > `$__fish_user_data_dir/pez` > `$XDG_DATA_HOME/fish/pez` > `~/.local/share/fish/pez`

When you install a plugin, pez clones its repository into `pez_data_dir`.
If the directory doesn’t exist, pez will create it.
If the repository is already cloned, pez will notify you and skip cloning
unless you use the --force option to re-clone it.

After cloning, if the repository contains functions, completions, conf.d,
or themes directories, pez will recursively copy files from these directories
to the corresponding fish configuration directories:

- `~/.config/fish/functions`
- `~/.config/fish/completions`
- `~/.config/fish/conf.d`
- `~/.config/fish/themes`

When installing from pez.toml (no explicit targets), existing files at the
destination are overwritten. When installing explicit targets on the CLI,
duplicate destination paths are skipped with a warning to avoid conflicts.

The destination fish configuration directory can be overridden
using the following environment variables:
`$__fish_config_dir` > `$XDG_CONFIG_HOME/fish` > `~/.config/fish`

Additionally, `pez-lock.toml` records information about the installed packages
and the files copied. It is created in the same directory as `pez.toml`
and will append information if it already exists.

### Concurrency

Control job parallelism for upgrade/uninstall/prune with `PEZ_JOBS` (default: 4).

## Acknowledgements

pez is inspired by the following projects:

- [fisher](https://github.com/jorgebucaran/fisher)
- [oh-my-fish](https://github.com/oh-my-fish/oh-my-fish)
- [fundle](https://github.com/danhper/fundle)

## License

MIT

## Author

tetzng
</file>

<file path="src/cmd/upgrade.rs">
use crate::{
    cli::UpgradeArgs,
    config::PluginSpec,
    git,
    lock_file::Plugin,
    models::{PluginRepo, TargetDir},
    utils,
};

use console::Emoji;
use futures::{StreamExt, stream};
use std::fs;
use tracing::{error, info, warn};

pub(crate) async fn run(args: &UpgradeArgs) -> anyhow::Result<()> {
    info!("{}Starting upgrade process...", Emoji("🔍 ", ""));
    if let Some(plugins) = &args.plugins {
        let jobs = utils::load_jobs();
        let tasks = stream::iter(plugins.iter())
            .map(|plugin| {
                let plugin = plugin.clone();
                tokio::task::spawn_blocking(move || {
                    info!("\n{}Upgrading plugin: {}", Emoji("✨ ", ""), &plugin);
                    let res = upgrade(&plugin);
                    if res.is_ok() {
                        info!(
                            "{}Successfully upgraded plugin: {}",
                            Emoji("✅ ", ""),
                            &plugin
                        );
                    }
                    res
                })
            })
            .buffer_unordered(jobs);
        let results: Vec<_> = tasks.collect().await;
        for r in results {
            r??;
        }
    } else {
        upgrade_all().await?;
    }
    info!(
        "\n{}All specified plugins have been upgraded successfully!",
        Emoji("🎉 ", "")
    );

    Ok(())
}

fn upgrade(plugin: &PluginRepo) -> anyhow::Result<()> {
    let (mut config, config_path) = utils::load_or_create_config()?;

    match config.plugins {
        Some(ref mut plugin_specs) => {
            if !plugin_specs
                .iter()
                .any(|p| p.get_plugin_repo().is_ok_and(|r| r == *plugin))
            {
                plugin_specs.push(PluginSpec {
                    name: None,
                    source: crate::config::PluginSource::Repo {
                        repo: plugin.clone(),
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                });
                config.save(&config_path)?;
            }
        }
        None => {
            config.plugins = Some(vec![PluginSpec {
                name: None,
                source: crate::config::PluginSource::Repo {
                    repo: plugin.clone(),
                    version: None,
                    branch: None,
                    tag: None,
                    commit: None,
                },
            }]);
            config.save(&config_path)?;
        }
    }

    upgrade_plugin(plugin)?;

    Ok(())
}

async fn upgrade_all() -> anyhow::Result<()> {
    let (config, _) = utils::load_or_create_config()?;
    if let Some(plugins) = &config.plugins {
        let jobs = utils::load_jobs();
        let tasks = stream::iter(plugins.iter())
            .map(|plugin_spec| {
                let repo = plugin_spec.get_plugin_repo().unwrap();
                tokio::task::spawn_blocking(move || {
                    info!("\n{}Upgrading plugin: {}", Emoji("✨ ", ""), &repo);
                    upgrade_plugin(&repo)
                })
            })
            .buffer_unordered(jobs);
        let results: Vec<_> = tasks.collect().await;
        for r in results {
            r??;
        }
    }

    Ok(())
}

fn upgrade_plugin(plugin_repo: &PluginRepo) -> anyhow::Result<()> {
    let (mut lock_file, lock_file_path) = utils::load_or_create_lock_file()?;
    let config_dir = utils::load_fish_config_dir()?;

    match lock_file.get_plugin_by_repo(plugin_repo) {
        Some(lock_file_plugin) => {
            let repo_path = utils::load_pez_data_dir()?.join(lock_file_plugin.repo.as_str());
            if git::is_local_source(&lock_file_plugin.source) {
                info!(
                    "{}{} Plugin {} is a local source; skipping upgrade.",
                    Emoji("🚧 ", ""),
                    console::style("Info:").cyan(),
                    plugin_repo
                );
                return Ok(());
            }
            if repo_path.exists() {
                let repo = git2::Repository::open(&repo_path)?;
                let latest_remote_commit = git::get_latest_remote_commit(&repo)?;
                if latest_remote_commit == lock_file_plugin.commit_sha {
                    info!(
                        "{}{} Plugin {} is already up to date.",
                        Emoji("🚀 ", ""),
                        console::style("Info:").cyan(),
                        plugin_repo
                    );
                    return Ok(());
                }

                repo.set_head_detached(git2::Oid::from_str(&latest_remote_commit)?)?;

                lock_file_plugin.files.iter().for_each(|file| {
                    let dest_path = config_dir.join(file.dir.as_str()).join(&file.name);
                    if dest_path.exists() {
                        fs::remove_file(&dest_path).unwrap();
                    }
                });
                let mut updated_plugin = Plugin {
                    name: lock_file_plugin.name.to_string(),
                    repo: plugin_repo.clone(),
                    source: lock_file_plugin.source.clone(),
                    commit_sha: latest_remote_commit,
                    files: vec![],
                };
                info!("{:?}", updated_plugin);

                utils::copy_plugin_files_from_repo(&repo_path, &mut updated_plugin)?;

                updated_plugin
                    .files
                    .iter()
                    .filter(|f| f.dir == TargetDir::ConfD)
                    .for_each(|f| {
                        if let Err(e) = utils::emit_event(&f.name, &utils::Event::Update) {
                            error!("Failed to emit event for {}: {:?}", &f.name, e);
                        }
                    });

                if let Err(e) = lock_file.upsert_plugin_by_repo(updated_plugin) {
                    warn!("Failed to update lock file: {:?}", e);
                }
                lock_file.save(&lock_file_path)?;
            } else {
                let path_display = repo_path.display();
                warn!(
                    "{}{} Repository directory at {} does not exist.",
                    Emoji("🚧 ", ""),
                    console::style("Warning:").yellow(),
                    path_display
                );
                warn!("{}You need to install the plugin first.", Emoji("🚧 ", ""),);
            }
        }
        None => {
            anyhow::bail!("Plugin is not installed: {}", plugin_repo);
        }
    }

    Ok(())
}
</file>

<file path="src/git.rs">
use crate::resolver::Selection;
use git2::{Cred, Error, FetchOptions, RemoteCallbacks};
use std::path;

pub(crate) fn clone_repository(
    repo_url: &str,
    target_path: &path::Path,
) -> anyhow::Result<git2::Repository> {
    let callbacks = setup_remote_callbacks();
    let fetch_options = setup_fetch_options(callbacks);

    let mut clone_options = git2::build::RepoBuilder::new();
    clone_options.fetch_options(fetch_options);
    let repo = clone_options.clone(repo_url, target_path)?;

    Ok(repo)
}

fn setup_remote_callbacks() -> RemoteCallbacks<'static> {
    let mut callbacks = RemoteCallbacks::new();
    callbacks.credentials(|_, _, _| Cred::default());
    callbacks
}

fn setup_fetch_options(callbacks: RemoteCallbacks<'static>) -> FetchOptions<'static> {
    let mut fetch_options = FetchOptions::new();
    fetch_options.remote_callbacks(callbacks);
    // Download all tags to support @tag checkouts.
    fetch_options.download_tags(git2::AutotagOption::All);
    fetch_options
}

pub(crate) fn get_latest_commit_sha(repo: git2::Repository) -> Result<String, git2::Error> {
    let commit = repo.head()?.peel_to_commit()?;

    Ok(commit.id().to_string())
}

/// Attempts to checkout the provided git `refspec` (tag/branch/commit) and returns the checked out commit sha.
#[allow(dead_code)]
pub(crate) fn checkout_ref(repo: &git2::Repository, refspec: &str) -> anyhow::Result<String> {
    // Try to resolve as any object (commit, tag, branch)
    let obj = repo
        .revparse_single(refspec)
        .or_else(|_| repo.revparse_single(&format!("refs/tags/{refspec}")))?;
    repo.set_head_detached(obj.id())?;
    Ok(obj.id().to_string())
}

/// Rough heuristic: a source is a local path if it starts with '/', './', '../', or '~'.
pub(crate) fn is_local_source(source: &str) -> bool {
    source.starts_with('/')
        || source.starts_with("./")
        || source.starts_with("../")
        || source.starts_with('~')
}

pub(crate) fn fetch_all(repo: &git2::Repository) -> anyhow::Result<()> {
    let mut cb = RemoteCallbacks::new();
    cb.credentials(|_url, username, _allowed| {
        if let Some(username) = username {
            Cred::ssh_key_from_agent(username)
        } else {
            Err(git2::Error::from_str("No username provided"))
        }
    });
    let mut fo = FetchOptions::new();
    fo.remote_callbacks(cb);
    fo.download_tags(git2::AutotagOption::All);
    let mut remote = repo.find_remote("origin")?;
    remote.fetch(
        &[
            "refs/heads/*:refs/remotes/origin/*",
            "refs/tags/*:refs/tags/*",
        ],
        Some(&mut fo),
        None,
    )?;
    Ok(())
}

pub(crate) fn get_remote_head_commit(repo: &git2::Repository) -> anyhow::Result<String> {
    fetch_all(repo)?;
    if let Ok(remote) = repo.find_remote("origin")
        && let Ok(buf) = remote.default_branch()
        && let Some(name) = buf.as_str()
        && let Some(branch) = name.strip_prefix("refs/heads/")
        && let Some(oid) = get_remote_branch_commit(repo, branch)?
    {
        return Ok(oid);
    }
    let remote_head_ref = "refs/remotes/origin/HEAD";
    let r = repo.find_reference(remote_head_ref)?.resolve()?;
    let oid = r
        .target()
        .ok_or_else(|| anyhow::anyhow!("Remote HEAD has no target"))?;
    Ok(oid.to_string())
}

pub(crate) fn get_remote_branch_commit(
    repo: &git2::Repository,
    branch: &str,
) -> anyhow::Result<Option<String>> {
    fetch_all(repo)?;
    let refname = format!("refs/remotes/origin/{branch}");
    match repo.find_reference(&refname) {
        Ok(r) => Ok(r.target().map(|oid| oid.to_string())),
        Err(_) => Ok(None),
    }
}

pub(crate) fn get_tag_commit(repo: &git2::Repository, tag: &str) -> anyhow::Result<Option<String>> {
    fetch_all(repo)?;
    let name = format!("refs/tags/{tag}");
    match repo.revparse_single(&name) {
        Ok(obj) => Ok(Some(obj.peel_to_commit()?.id().to_string())),
        Err(_) => Ok(None),
    }
}

pub(crate) fn list_tags(repo: &git2::Repository) -> anyhow::Result<Vec<String>> {
    fetch_all(repo)?;
    let names = repo.tag_names(None)?;
    let mut tags = Vec::new();
    for i in 0..names.len() {
        if let Some(name) = names.get(i) {
            tags.push(name.to_string());
        }
    }
    Ok(tags)
}

pub(crate) fn resolve_selection(
    repo: &git2::Repository,
    sel: &Selection,
) -> anyhow::Result<String> {
    match sel {
        Selection::DefaultHead | Selection::Latest => get_remote_head_commit(repo),
        Selection::Branch(name) => {
            if let Some(c) = get_remote_branch_commit(repo, name)? {
                tracing::debug!(branch = name, commit = %c, "Resolved branch to commit");
                Ok(c)
            } else {
                anyhow::bail!(format!("Branch not found: {name}"))
            }
        }
        Selection::Tag(t) => {
            if let Some(c) = get_tag_commit(repo, t)? {
                tracing::debug!(tag = t, commit = %c, "Resolved tag to commit");
                Ok(c)
            } else {
                anyhow::bail!(format!("Tag not found: {t}"))
            }
        }
        Selection::Commit(sha) => {
            let obj = repo
                .revparse_single(sha)
                .map_err(|e| anyhow::anyhow!("Failed to resolve commit '{sha}': {e}"))?;
            let id = obj.peel_to_commit()?.id().to_string();
            tracing::debug!(commit = %id, "Resolved explicit commit");
            Ok(id)
        }
        Selection::Version(v) => {
            let id = resolve_version(repo, v)?;
            tracing::debug!(version = v, commit = %id, "Resolved version to commit");
            Ok(id)
        }
    }
}

fn resolve_version(repo: &git2::Repository, v: &str) -> anyhow::Result<String> {
    if v == "latest" {
        return get_remote_head_commit(repo);
    }
    if let Some(c) = get_remote_branch_commit(repo, v)? {
        return Ok(c);
    }
    let tags = list_tags(repo)?;
    if let Some(tag) = pick_tag_for_version(&tags, v)?
        && let Some(c) = get_tag_commit(repo, &tag)?
    {
        return Ok(c);
    }
    anyhow::bail!(format!("No matching branch or tag for version: {v}"))
}

fn pick_tag_for_version(tags: &[String], v: &str) -> anyhow::Result<Option<String>> {
    use semver::Version;
    let v_trim = v.trim_start_matches('v');
    let parts: Vec<&str> = v_trim.split('.').collect();
    let mut semver_tags: Vec<(Version, String)> = Vec::new();
    for t in tags {
        let name = t.trim();
        let name_trim = name.trim_start_matches('v');
        if let Ok(ver) = Version::parse(name_trim) {
            // Exclude pre-release tags by default
            if ver.pre.is_empty() {
                semver_tags.push((ver, name.to_string()));
            }
        }
    }
    if !semver_tags.is_empty() {
        if parts.len() == 3
            && parts.iter().all(|p| p.chars().all(|c| c.is_ascii_digit()))
            && let Ok(want) = Version::parse(v_trim)
            && let Some((_, tag)) = semver_tags.iter().find(|(sv, _)| *sv == want)
        {
            tracing::debug!(version = %v, tag = %tag, "Matched exact semver tag");
            return Ok(Some(tag.clone()));
        }
        let want_major = parts.first().and_then(|s| s.parse::<u64>().ok());
        let want_minor = parts.get(1).and_then(|s| s.parse::<u64>().ok());
        if let Some(mj) = want_major {
            let mut candidates: Vec<(Version, String)> = semver_tags
                .into_iter()
                .filter(|(sv, _)| sv.major == mj && want_minor.is_none_or(|mn| sv.minor == mn))
                .collect();
            if !candidates.is_empty() {
                candidates.sort_by(|a, b| a.0.cmp(&b.0));
                let tag = candidates.last().map(|(_, tag)| tag.clone());
                if let Some(ref t) = tag {
                    tracing::debug!(version = %v, tag = %t, "Selected highest semver tag by prefix");
                }
                return Ok(tag);
            }
        }
    }
    if tags.iter().any(|t| t == v) {
        tracing::debug!(version = %v, tag = %v, "Matched non-semver exact tag");
        return Ok(Some(v.to_string()));
    }
    let mut candidates: Vec<(Vec<u64>, String)> = Vec::new();
    for t in tags {
        if t == v {
            return Ok(Some(t.clone()));
        }
        if let Some(rest) = t.strip_prefix(&format!("{v}.")) {
            let nums: Vec<u64> = rest
                .split('.')
                .map(|s| s.parse::<u64>().unwrap_or(0))
                .collect();
            candidates.push((nums, t.clone()));
        } else if let Some(rest) = t.strip_prefix(&format!("v{v}.")) {
            let nums: Vec<u64> = rest
                .split('.')
                .map(|s| s.parse::<u64>().unwrap_or(0))
                .collect();
            candidates.push((nums, t.clone()));
        }
    }
    if !candidates.is_empty() {
        candidates.sort_by(|a, b| a.0.cmp(&b.0));
        let tag = candidates.last().map(|(_, tag)| tag.clone());
        if let Some(ref t) = tag {
            tracing::debug!(version = %v, tag = %t, "Selected highest non-semver dotted suffix tag");
        }
        return Ok(tag);
    }
    Ok(None)
}

// tests are in a submodule at the end of file

fn get_remote_name(upstream: &git2::Branch) -> Result<String, Error> {
    let upstream_ref = upstream
        .get()
        .name()
        .ok_or_else(|| git2::Error::from_str("Upstream branch has no name"))?;
    let parts: Vec<&str> = upstream_ref.split('/').collect();
    if parts.len() < 3 {
        return Err(Error::from_str(&format!(
            "Invalid upstream reference format: {upstream_ref}"
        )));
    }
    Ok(parts[2].to_string())
}

pub(crate) fn get_latest_remote_commit(repo: &git2::Repository) -> anyhow::Result<String> {
    let head = repo.head()?;

    if head.is_branch() {
        let branch_name = head
            .shorthand()
            .ok_or_else(|| git2::Error::from_str("Invalid branch name"))?;

        let local_branch = repo.find_branch(branch_name, git2::BranchType::Local)?;

        let upstream = match local_branch.upstream() {
            Ok(u) => u,
            Err(_) => return Err(anyhow::anyhow!("No upstream branch set")),
        };

        let remote_name = get_remote_name(&upstream)?;

        let mut remote = repo.find_remote(&remote_name)?;

        let mut cb = RemoteCallbacks::new();
        cb.credentials(|_url, username, _allowed| {
            if let Some(username) = username {
                Cred::ssh_key_from_agent(username)
            } else {
                Err(git2::Error::from_str("No username provided"))
            }
        });

        let mut fetch_options = FetchOptions::new();
        fetch_options.remote_callbacks(cb);

        remote.fetch(
            &["refs/heads/*:refs/remotes/origin/*"],
            Some(&mut fetch_options),
            None,
        )?;

        let remote_branch_ref = format!("refs/remotes/{remote_name}/{branch_name}");
        let remote_ref = match repo.find_reference(&remote_branch_ref) {
            Ok(r) => r.resolve()?,
            Err(_) => {
                let err_msg = format!("Remote branch '{remote_branch_ref}' does not exist");
                return Err(anyhow::anyhow!(err_msg));
            }
        };

        let remote_oid = match remote_ref.target() {
            Some(oid) => oid,
            None => return Err(anyhow::anyhow!("Remote branch has no target")),
        };

        let remote_commit = repo.find_commit(remote_oid)?;

        Ok(remote_commit.id().to_string())
    } else {
        let remote_name = "origin";

        let mut remote = repo.find_remote(remote_name)?;

        let mut cb = RemoteCallbacks::new();
        cb.credentials(|_url, username, _allowed| {
            if let Some(username) = username {
                Cred::ssh_key_from_agent(username)
            } else {
                Err(git2::Error::from_str("No username provided"))
            }
        });

        let mut fetch_options = FetchOptions::new();
        fetch_options.remote_callbacks(cb);

        remote.fetch(
            &["refs/heads/*:refs/remotes/origin/*"],
            Some(&mut fetch_options),
            None,
        )?;

        let remote_head_ref = format!("refs/remotes/{remote_name}/HEAD");
        let remote_head_ref = match repo.find_reference(&remote_head_ref) {
            Ok(r) => r.resolve()?,
            Err(_) => {
                let err_msg = format!("Remote '{remote_name}' does not have HEAD");
                return Err(anyhow::anyhow!(err_msg));
            }
        };

        let remote_head_oid = match remote_head_ref.target() {
            Some(oid) => oid,
            None => return Err(anyhow::anyhow!("Remote HEAD has no target")),
        };

        let remote_head_commit = repo.find_commit(remote_head_oid)?;
        Ok(remote_head_commit.id().to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn pick_tag_for_version_semver_prefix() {
        let tags = vec![
            "v1.0.0".to_string(),
            "v1.2.0".to_string(),
            "v1.2.1".to_string(),
            "v2.0.0".to_string(),
            "v1.3.0-beta1".to_string(),
        ];
        let sel = pick_tag_for_version(&tags, "v1").unwrap().unwrap();
        assert_eq!(sel, "v1.2.1");
        let exact = pick_tag_for_version(&tags, "v2.0.0").unwrap().unwrap();
        assert_eq!(exact, "v2.0.0");
    }

    #[test]
    fn pick_tag_for_version_dotted_non_semver_prefix() {
        let tags = vec![
            "1.2.1".to_string(),
            "1.3.0".to_string(),
            "v1.4.5".to_string(),
            "2.0.0".to_string(),
        ];
        let sel = pick_tag_for_version(&tags, "1").unwrap().unwrap();
        // Should prefer highest among 1.x.y (either with or without v prefix)
        assert!(sel == "1.3.0" || sel == "v1.4.5");
    }
}
</file>

<file path="src/main.rs">
use clap::Parser;
use tracing::Level;
use tracing_subscriber::EnvFilter;

mod cli;
mod cmd;
mod config;
mod git;
mod lock_file;
mod models;
mod resolver;
mod utils;

#[cfg(test)]
mod tests_support;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = cli::Cli::parse();

    // Configure logging level from -v count, or RUST_LOG if provided
    let level = match cli.verbose {
        0 => Level::INFO,
        1 => Level::INFO,
        _ => Level::DEBUG,
    };
    let filter = std::env::var("RUST_LOG")
        .ok()
        .unwrap_or_else(|| level.as_str().to_lowercase());

    tracing_subscriber::fmt()
        .compact()
        .with_level(false)
        .with_target(false)
        .without_time()
        .with_env_filter(EnvFilter::new(filter))
        .init();

    match &cli.command {
        cli::Commands::Init => {
            cmd::init::run()?;
        }
        cli::Commands::Install(args) => {
            cmd::install::run(args).await?;
        }
        cli::Commands::Uninstall(args) => {
            cmd::uninstall::run(args).await?;
        }
        cli::Commands::Upgrade(args) => {
            cmd::upgrade::run(args).await?;
        }
        cli::Commands::List(args) => {
            cmd::list::run(args)?;
        }
        cli::Commands::Prune(args) => {
            cmd::prune::run(args).await?;
        }
        cli::Commands::Doctor(args) => {
            cmd::doctor::run(args)?;
        }
        cli::Commands::Migrate(args) => {
            cmd::migrate::run(args).await?;
        }
        cli::Commands::Completions { shell } => match shell {
            cli::ShellType::Fish => cmd::completion::generate_completion(clap_complete::aot::Fish),
        },
    }

    Ok(())
}
</file>

<file path="src/cmd/install.rs">
use crate::resolver;
use crate::resolver::{ref_kind_to_repo_source, ref_kind_to_url_source};
use crate::{
    cli::InstallArgs,
    config, git,
    lock_file::{LockFile, Plugin},
    models::TargetDir,
    models::{InstallTarget, PluginRepo, ResolvedInstallTarget},
    utils,
};

use console::Emoji;
use futures::future;
use std::{fs, path, result, sync::Arc};
use tokio::sync::Mutex;
use tracing::{debug, info, warn};

pub(crate) async fn run(args: &InstallArgs) -> anyhow::Result<()> {
    info!("{}Starting installation process...", Emoji("🔍 ", ""));

    handle_installation(args).await?;

    Ok(())
}

async fn handle_installation(args: &InstallArgs) -> anyhow::Result<()> {
    if let Some(plugins) = &args.plugins {
        install(plugins, &args.force).await?;
        info!(
            "\n{}All specified plugins have been installed successfully!",
            Emoji("🎉 ", "")
        );
    } else {
        install_all(&args.force, &args.prune)?;
    }

    Ok(())
}

async fn install(targets: &[InstallTarget], force: &bool) -> anyhow::Result<()> {
    let (mut config, config_path) = utils::load_or_create_config()?;
    add_plugins_to_config(&mut config, &config_path, targets)?;

    let (mut lock_file, lock_file_path) = utils::load_or_create_lock_file()?;

    let pez_data_dir = utils::load_pez_data_dir()?;
    let resolved: Vec<ResolvedInstallTarget> = targets
        .iter()
        .map(|t| t.resolve())
        .collect::<anyhow::Result<Vec<_>>>()?;
    let mut new_plugins =
        clone_plugins(&resolved, *force, lock_file.clone(), &pez_data_dir).await?;

    let new_plugins = sync_plugin_files(&mut new_plugins, &pez_data_dir).await?;

    for plugin in &new_plugins {
        emit_event(plugin, &utils::Event::Install)?;
    }

    lock_file.merge_plugins(new_plugins);
    lock_file.save(&lock_file_path)?;
    info!(
        "{}All plugins have been installed successfully!",
        Emoji("✅ ", "")
    );
    Ok(())
}

fn emit_event(plugin: &Plugin, event: &utils::Event) -> anyhow::Result<()> {
    plugin
        .files
        .iter()
        .filter(|f| f.dir == TargetDir::ConfD)
        .for_each(|f| {
            let _ = utils::emit_event(&f.name, event);
        });

    Ok(())
}

fn add_plugins_to_config(
    config: &mut config::Config,
    config_path: &path::Path,
    targets: &[InstallTarget],
) -> anyhow::Result<()> {
    let resolved: Vec<ResolvedInstallTarget> = targets
        .iter()
        .map(|t| t.resolve())
        .collect::<anyhow::Result<Vec<_>>>()?;
    match config.plugins {
        Some(ref mut plugin_specs) => {
            for r in &resolved {
                if !plugin_specs
                    .iter()
                    .any(|p| p.get_plugin_repo().is_ok_and(|pr| pr == r.plugin_repo))
                {
                    let default_source = format!("https://github.com/{}", r.plugin_repo.as_str());
                    let spec = if r.is_local {
                        config::PluginSpec {
                            name: None,
                            source: config::PluginSource::Path {
                                path: r.source.clone(),
                            },
                        }
                    } else if r.source == default_source {
                        config::PluginSpec {
                            name: None,
                            source: ref_kind_to_repo_source(&r.plugin_repo, &r.ref_kind),
                        }
                    } else {
                        config::PluginSpec {
                            name: None,
                            source: ref_kind_to_url_source(&r.source, &r.ref_kind),
                        }
                    };
                    plugin_specs.push(spec);
                }
            }
        }
        None => {
            let plugin_specs = resolved
                .into_iter()
                .map(|r| {
                    let default_source = format!("https://github.com/{}", r.plugin_repo.as_str());
                    if r.is_local {
                        config::PluginSpec {
                            name: None,
                            source: config::PluginSource::Path { path: r.source },
                        }
                    } else if r.source == default_source {
                        config::PluginSpec {
                            name: None,
                            source: ref_kind_to_repo_source(&r.plugin_repo, &r.ref_kind),
                        }
                    } else {
                        config::PluginSpec {
                            name: None,
                            source: ref_kind_to_url_source(&r.source, &r.ref_kind),
                        }
                    }
                })
                .collect();
            config.plugins = Some(plugin_specs);
        }
    }
    config.save(&config_path.to_path_buf())?;

    Ok(())
}

async fn clone_plugins(
    resolved_targets: &[ResolvedInstallTarget],
    force: bool,
    lock_file: LockFile,
    pez_data_dir: &path::Path,
) -> anyhow::Result<Vec<Plugin>> {
    let lock_file = Arc::new(Mutex::new(lock_file));
    let new_lock_plugins: Arc<Mutex<Vec<Plugin>>> = Arc::new(Mutex::new(vec![]));

    let clone_tasks: Vec<_> = resolved_targets
        .iter()
        .cloned()
        .map(|resolved| {
            let new_lock_plugins = Arc::clone(&new_lock_plugins);
            let lock_file = Arc::clone(&lock_file);
            let pez_data_dir = pez_data_dir.to_path_buf();

            tokio::spawn(async move {
                let plugin_repo = resolved.plugin_repo.clone();
                let plugin_repo_str = plugin_repo.as_str();
                let repo_path = pez_data_dir.join(&plugin_repo_str);

                if repo_path.exists()
                    && let Err(e) = handle_existing_repository(&force, &plugin_repo, &repo_path)
                {
                    warn!(
                        "Failed to prepare existing repository {}: {:?}",
                        repo_path.display(),
                        e
                    );
                    return; // skip this plugin task on error
                }

                let base_source = resolved.source.clone();

                let repo_path_display = repo_path.display();
                info!(
                    "{}Cloning repository from {} to {}",
                    Emoji("🔗 ", ""),
                    &base_source,
                    repo_path_display
                );
                if resolved.is_local {
                    // Local source; skip clone. We'll copy files from `base_source` later in sync.
                    let name = &plugin_repo.repo;
                    let new_plugin = Plugin {
                        name: name.to_string(),
                        repo: plugin_repo.clone(),
                        source: base_source.clone(),
                        commit_sha: "local".to_string(),
                        files: vec![],
                    };
                    new_lock_plugins.lock().await.push(new_plugin);
                    return;
                }

                let repo = match git::clone_repository(&base_source, &repo_path) {
                    Ok(r) => r,
                    Err(e) => {
                        warn!(
                            "Failed to clone {} to {}: {:?}",
                            base_source,
                            repo_path.display(),
                            e
                        );
                        return;
                    }
                };
                let name = &plugin_repo.repo;
                let new_plugin = {
                    let locked_opt = lock_file
                        .lock()
                        .await
                        .get_plugin_by_repo(&plugin_repo)
                        .cloned();
                    if let Some(lock_file_plugin) = locked_opt {
                        if !force {
                            info!(
                                "{}Checking out commit sha: {}",
                                Emoji("🔄 ", ""),
                                &lock_file_plugin.commit_sha
                            );
                            if let Ok(oid) = git2::Oid::from_str(&lock_file_plugin.commit_sha) {
                                if let Err(e) = repo.set_head_detached(oid) {
                                    warn!(
                                        "Failed to detach HEAD to {}: {:?}",
                                        lock_file_plugin.commit_sha, e
                                    );
                                }
                            } else {
                                warn!(
                                    "Invalid commit SHA in lock file: {}",
                                    lock_file_plugin.commit_sha
                                );
                            }
                            Plugin {
                                name: name.to_string(),
                                repo: plugin_repo.clone(),
                                source: base_source.clone(),
                                commit_sha: lock_file_plugin.commit_sha.clone(),
                                files: vec![],
                            }
                        } else {
                            // force: resolve newest according to ref_kind
                            let sel = resolver::selection_from_ref_kind(&resolved.ref_kind);
                            let commit_sha = match git::resolve_selection(&repo, &sel) {
                                std::result::Result::Ok(sha) => sha,
                                Err(e) => {
                                    warn!(
                                        "Failed to resolve selection: {:?}. Falling back to HEAD.",
                                        e
                                    );
                                    match git::get_latest_commit_sha(repo) {
                                        Ok(s) => s,
                                        Err(e) => {
                                            warn!("Failed to read HEAD commit: {:?}", e);
                                            return;
                                        }
                                    }
                                }
                            };
                            Plugin {
                                name: name.to_string(),
                                repo: plugin_repo.clone(),
                                source: base_source.clone(),
                                commit_sha,
                                files: vec![],
                            }
                        }
                    } else {
                        // fresh install: resolve selection
                        let sel = resolver::selection_from_ref_kind(&resolved.ref_kind);
                        let commit_sha = match git::resolve_selection(&repo, &sel) {
                            std::result::Result::Ok(sha) => sha,
                            Err(e) => {
                                warn!(
                                    "Failed to resolve selection: {:?}. Falling back to HEAD.",
                                    e
                                );
                                git::get_latest_commit_sha(repo).unwrap()
                            }
                        };
                        Plugin {
                            name: name.to_string(),
                            repo: plugin_repo.clone(),
                            source: base_source.clone(),
                            commit_sha,
                            files: vec![],
                        }
                    }
                };
                new_lock_plugins.lock().await.push(new_plugin);
            })
        })
        .collect();

    future::join_all(clone_tasks).await;

    let new_lock_plugins_result = Arc::try_unwrap(new_lock_plugins);

    match new_lock_plugins_result {
        result::Result::Ok(new_lock_plugins) => Ok(new_lock_plugins.into_inner()),
        Err(_) => panic!("Failed to unwrap new_lock_plugins"),
    }
}

fn handle_existing_repository(
    force: &bool,
    repo: &PluginRepo,
    repo_path: &path::Path,
) -> anyhow::Result<()> {
    if *force {
        fs::remove_dir_all(repo_path)?;
    } else {
        anyhow::bail!(
            "{}{} Plugin already exists: {}, Use --force to reinstall",
            Emoji("❌ ", ""),
            console::style("Error:").red().bold(),
            repo.as_str()
        );
    }
    Ok(())
}

async fn sync_plugin_files(
    new_plugins: &mut [Plugin],
    pez_data_dir: &path::Path,
) -> anyhow::Result<Vec<Plugin>> {
    use std::collections::HashSet;
    info!(
        "\n{}Copying plugin files to fish config directory...",
        Emoji("🐟 ", "")
    );
    let config_dir = utils::load_fish_config_dir()?;
    let mut dest_paths: HashSet<path::PathBuf> = HashSet::new();

    for plugin in new_plugins.iter_mut() {
        let repo_path = if git::is_local_source(&plugin.source) {
            path::PathBuf::from(&plugin.source)
        } else {
            pez_data_dir.join(plugin.repo.as_str())
        };

        info!("{}Copying files:", Emoji("📂 ", ""));
        let outcome =
            utils::copy_plugin_files(&repo_path, &config_dir, plugin, Some(&mut dest_paths), true)?;
        if outcome.skipped_due_to_duplicate {
            warn!(
                "{} Skipping plugin due to duplicate: {}",
                Emoji("🚨 ", ""),
                plugin.repo
            );
            // Clear any partially accumulated file records for safety
            plugin.files.clear();
        }
    }

    Ok(new_plugins.to_vec())
}

fn install_all(force: &bool, prune: &bool) -> anyhow::Result<()> {
    let (mut lock_file, lock_file_path) = utils::load_or_create_lock_file()?;
    let (config, _) = utils::load_config()?;

    let plugin_specs = match config.plugins {
        Some(plugins) => plugins,
        None => {
            info!("No plugins found in pez.toml");
            vec![]
        }
    };

    for plugin_spec in plugin_specs.iter() {
        let resolved = plugin_spec.to_resolved()?;
        let repo_for_id = resolved.plugin_repo.clone();
        let source_base = resolved.source.clone();
        let ref_kind = resolved.ref_kind.clone();
        let repo_path = utils::load_pez_data_dir()?.join(repo_for_id.as_str());

        info!("\n{}Installing plugin: {}", Emoji("🐟 ", ""), &repo_for_id);
        match lock_file.get_plugin_by_repo(&repo_for_id) {
            Some(locked_plugin) => {
                if repo_path.exists() && !*force {
                    info!(
                        "{}Skipped: {} is already installed.",
                        Emoji("⏭️  ", ""),
                        repo_for_id
                    );

                    continue;
                }

                let repo_path_display = repo_path.display();
                info!(
                    "{}Cloning repository from {} to {}",
                    Emoji("🔗 ", ""),
                    &source_base,
                    repo_path_display
                );
                // For local path sources, cloning is not applicable
                let repo = if git::is_local_source(&source_base) {
                    None
                } else {
                    Some(git::clone_repository(&source_base, &repo_path)?)
                };
                let commit_sha = if *force {
                    if let Some(repo) = &repo {
                        let sel = resolver::selection_from_ref_kind(&ref_kind);
                        match git::resolve_selection(repo, &sel) {
                            std::result::Result::Ok(sha) => sha,
                            Err(e) => {
                                warn!(
                                    "Failed to resolve selection: {:?}. Falling back to pinned.",
                                    e
                                );
                                locked_plugin.commit_sha.clone()
                            }
                        }
                    } else {
                        "local".to_string()
                    }
                } else {
                    if let Some(repo) = &repo {
                        info!(
                            "{}Using pinned commit: {}",
                            Emoji("🔄 ", ""),
                            &locked_plugin.commit_sha
                        );
                        if let Ok(oid) = git2::Oid::from_str(&locked_plugin.commit_sha) {
                            let _ = repo.set_head_detached(oid);
                        }
                    }
                    locked_plugin.commit_sha.clone()
                };
                debug!(repo = %repo_for_id, source = %source_base, commit = %commit_sha, "Install resolved commit");
                let mut plugin = Plugin {
                    name: plugin_spec.get_name()?,
                    repo: repo_for_id.clone(),
                    source: source_base.to_string(),
                    commit_sha,
                    files: vec![],
                };
                if git::is_local_source(&source_base) {
                    utils::copy_plugin_files_from_repo(path::Path::new(&source_base), &mut plugin)?;
                } else {
                    utils::copy_plugin_files_from_repo(&repo_path, &mut plugin)?;
                }
                emit_event(&plugin, &utils::Event::Install)?;

                if let Err(e) = lock_file.upsert_plugin_by_repo(plugin) {
                    warn!("Failed to update lock file entry: {:?}", e);
                }
                lock_file.save(&lock_file_path)?;
            }
            None => {
                if repo_path.exists() && !git::is_local_source(&source_base) {
                    if *force {
                        fs::remove_dir_all(&repo_path)?;
                    } else {
                        anyhow::bail!(
                            "Plugin already exists: {} (path: {}). Use --force to reinstall",
                            repo_for_id,
                            repo_path.display()
                        );
                    }
                }

                let commit_sha = if git::is_local_source(&source_base) {
                    info!(
                        "{}Installing from local path: {}",
                        Emoji("📁 ", ""),
                        &source_base
                    );
                    "local".to_string()
                } else {
                    let repo = git::clone_repository(&source_base, &repo_path)?;
                    let sel = resolver::selection_from_ref_kind(&ref_kind);
                    match git::resolve_selection(&repo, &sel) {
                        std::result::Result::Ok(sha) => sha,
                        Err(e) => {
                            warn!(
                                "Failed to resolve selection: {:?}. Falling back to HEAD.",
                                e
                            );
                            git::get_latest_commit_sha(repo)?
                        }
                    }
                };
                let mut plugin = Plugin {
                    name: plugin_spec.get_name()?,
                    repo: repo_for_id.clone(),
                    source: source_base.to_string(),
                    commit_sha,
                    files: vec![],
                };
                if git::is_local_source(&source_base) {
                    utils::copy_plugin_files_from_repo(path::Path::new(&source_base), &mut plugin)?;
                } else {
                    utils::copy_plugin_files_from_repo(&repo_path, &mut plugin)?;
                }
                emit_event(&plugin, &utils::Event::Install)?;

                if let Err(e) = lock_file.upsert_plugin_by_repo(plugin) {
                    warn!("Failed to add lock file entry: {:?}", e);
                }
                lock_file.save(&lock_file_path)?;
            }
        }
    }

    let ignored_lock_file_plugins = lock_file
        .plugins
        .iter()
        .filter(|p| {
            !plugin_specs
                .iter()
                .any(|spec| spec.get_plugin_repo().is_ok_and(|r| r == p.repo))
        })
        .cloned()
        .collect::<Vec<Plugin>>();

    if !ignored_lock_file_plugins.is_empty() {
        if *prune {
            for plugin in ignored_lock_file_plugins {
                info!("\n{}Removing plugin: {}", Emoji("🐟 ", ""), &plugin.name);
                let repo_path = utils::load_pez_data_dir()?.join(plugin.repo.as_str());
                if repo_path.exists() {
                    fs::remove_dir_all(&repo_path)?;
                } else {
                    let path_display = repo_path.display();
                    warn!(
                        "{}Repository directory at {} does not exist.",
                        Emoji("🚧 ", ""),
                        path_display
                    );

                    if !force {
                        info!(
                            "{}Detected plugin files based on pez-lock.toml:",
                            Emoji("📄 ", ""),
                        );
                        let fish_config_dir = utils::load_fish_config_dir()?;

                        plugin.files.iter().for_each(|file| {
                            let dest_path =
                                fish_config_dir.join(file.dir.as_str()).join(&file.name);
                            info!("   - {}", dest_path.display());
                        });
                        info!("If you want to remove these files, use the --force flag.");
                        continue;
                    }
                }

                info!(
                    "{}Removing plugin files based on pez-lock.toml:",
                    Emoji("🗑️  ", ""),
                );

                emit_event(&plugin, &utils::Event::Uninstall)?;

                let fish_config_dir = utils::load_fish_config_dir()?;
                plugin.files.iter().for_each(|file| {
                    let dest_path = fish_config_dir.join(file.dir.as_str()).join(&file.name);
                    if dest_path.exists() {
                        let path_display = dest_path.display();
                        info!("   - {}", path_display);
                        fs::remove_file(&dest_path).unwrap();
                    }
                    lock_file.remove_plugin(&plugin.source);
                    lock_file.save(&lock_file_path).unwrap();
                });
            }
        } else {
            info!("\nNotice: The following plugins are in pez-lock.toml but not in pez.toml:");
            for plugin in ignored_lock_file_plugins {
                info!("  - {}", plugin.name);
            }
            info!("If you want to remove them completely, please run:");
            info!("  pez install --prune");
            info!("or:");
            info!("  pez prune");
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use config::{PluginSource, PluginSpec};

    use super::*;
    use crate::tests_support::env::TestEnvironmentSetup;

    struct TestDataBuilder {
        new_plugin_spec: PluginSpec,
        added_plugin_spec: PluginSpec,
    }

    impl TestDataBuilder {
        fn new() -> Self {
            Self {
                new_plugin_spec: PluginSpec {
                    name: None,
                    source: PluginSource::Repo {
                        repo: PluginRepo {
                            owner: "owner".to_string(),
                            repo: "new-repo".to_string(),
                        },
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                },
                added_plugin_spec: PluginSpec {
                    name: None,
                    source: PluginSource::Repo {
                        repo: PluginRepo {
                            owner: "owner".to_string(),
                            repo: "added-repo".to_string(),
                        },
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                },
            }
        }
        fn build(self) -> TestData {
            TestData {
                new_plugin_spec: self.new_plugin_spec,
                added_plugin_spec: self.added_plugin_spec,
            }
        }
    }

    struct TestData {
        #[allow(dead_code)]
        new_plugin_spec: PluginSpec,
        added_plugin_spec: PluginSpec,
    }

    #[test]
    fn test_add_plugin_in_empty_config() {
        let mut test_env = TestEnvironmentSetup::new();
        let _test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config { plugins: None });

        let config = test_env.config.as_mut().expect("Config is not initialized");
        let targets = vec![crate::models::InstallTarget::from_raw("owner/new-repo")];

        let result = add_plugins_to_config(config, &test_env.config_path, &targets);
        assert!(result.is_ok());

        let updated_config = config::load(&test_env.config_path).unwrap();
        let updated_plugin_specs = updated_config.plugins.unwrap();
        assert_eq!(updated_plugin_specs.len(), 1);
        assert_eq!(
            updated_plugin_specs[0].get_plugin_repo().unwrap().as_str(),
            "owner/new-repo"
        );
    }

    #[test]
    fn test_add_existing_plugin_to_config() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.added_plugin_spec.clone()]),
        });

        let config = test_env.config.as_mut().expect("Config is not initialized");
        assert_eq!(config.plugins.as_ref().unwrap().len(), 1);

        let targets = vec![crate::models::InstallTarget::from_raw("owner/added-repo")];

        let result = add_plugins_to_config(config, &test_env.config_path, &targets);
        assert!(result.is_ok());

        let updated_config = config::load(&test_env.config_path).unwrap();
        let updated_plugin_specs = updated_config.plugins.unwrap();
        assert_eq!(updated_plugin_specs.len(), 1);
        assert_eq!(
            updated_plugin_specs[0].get_plugin_repo().unwrap().as_str(),
            "owner/added-repo"
        );
    }

    #[test]
    fn test_add_new_plugin_to_existing_config() {
        let mut test_env = TestEnvironmentSetup::new();
        let test_data = TestDataBuilder::new().build();
        test_env.setup_config(config::Config {
            plugins: Some(vec![test_data.added_plugin_spec.clone()]),
        });

        let config = test_env.config.as_mut().expect("Config is not initialized");
        assert_eq!(config.plugins.as_ref().unwrap().len(), 1);

        let targets = vec![crate::models::InstallTarget::from_raw("owner/new-repo")];

        let result = add_plugins_to_config(config, &test_env.config_path, &targets);
        assert!(result.is_ok());

        let updated_config = config::load(&test_env.config_path).unwrap();
        let updated_plugin_specs = updated_config.plugins.unwrap();
        assert_eq!(updated_plugin_specs.len(), 2);
        assert!(updated_plugin_specs.iter().any(|p| {
            p.get_plugin_repo()
                .map(|r| r.as_str() == "owner/added-repo")
                .unwrap_or(false)
        }));
        assert!(updated_plugin_specs.iter().any(|p| {
            p.get_plugin_repo()
                .map(|r| r.as_str() == "owner/new-repo")
                .unwrap_or(false)
        }));
    }

    #[test]
    fn test_handle_existing_repository_with_force() {
        let test_env = TestEnvironmentSetup::new();
        let repo = PluginRepo {
            owner: "owner".to_string(),
            repo: "repo".to_string(),
        };
        test_env.setup_data_repo(vec![repo.clone()]);
        let repo_path = test_env.data_dir.join(repo.as_str());

        let result = handle_existing_repository(&true, &repo, &repo_path);
        assert!(result.is_ok());
        assert!(!repo_path.exists());
    }

    #[test]
    fn test_repository_handling_without_force() {
        let test_env = TestEnvironmentSetup::new();
        let repo = PluginRepo {
            owner: "owner".to_string(),
            repo: "repo".to_string(),
        };
        test_env.setup_data_repo(vec![repo.clone()]);
        let repo_path = test_env.data_dir.join(repo.as_str());

        let result = handle_existing_repository(&false, &repo, &repo_path);
        assert!(result.is_err());
        assert!(repo_path.exists());
    }
}
</file>

<file path="src/utils.rs">
use crate::{
    config,
    lock_file::{self, LockFile, Plugin, PluginFile},
    models::TargetDir,
};
use anyhow::Context;
use console::Emoji;
use std::{collections::HashSet, env, fmt, fs, path};
use tracing::{debug, error, info, warn};
use walkdir::WalkDir;

fn home_dir() -> anyhow::Result<path::PathBuf> {
    if let Some(dir) = env::var_os("HOME") {
        return Ok(path::PathBuf::from(dir));
    }

    Err(anyhow::anyhow!("Could not determine home directory"))
}

pub(crate) fn load_fish_config_dir() -> anyhow::Result<path::PathBuf> {
    if let Some(dir) = env::var_os("__fish_config_dir") {
        return Ok(path::PathBuf::from(dir));
    }

    if let Some(dir) = env::var_os("XDG_CONFIG_HOME") {
        return Ok(path::PathBuf::from(dir).join("fish"));
    }

    let home = home_dir()?;
    Ok(home.join(".config").join("fish"))
}

pub(crate) fn load_pez_config_dir() -> anyhow::Result<path::PathBuf> {
    if let Some(dir) = env::var_os("PEZ_CONFIG_DIR") {
        return Ok(path::PathBuf::from(dir));
    }

    load_fish_config_dir()
}

pub(crate) fn load_lock_file_dir() -> anyhow::Result<path::PathBuf> {
    load_pez_config_dir()
}

pub(crate) fn load_fish_data_dir() -> anyhow::Result<path::PathBuf> {
    if let Some(dir) = env::var_os("__fish_user_data_dir") {
        return Ok(path::PathBuf::from(dir));
    }

    if let Some(dir) = env::var_os("XDG_DATA_HOME") {
        return Ok(path::PathBuf::from(dir).join("fish"));
    }

    let home = home_dir()?;
    Ok(home.join(".local/share/fish"))
}

pub(crate) fn load_pez_data_dir() -> anyhow::Result<path::PathBuf> {
    if let Some(dir) = env::var_os("PEZ_DATA_DIR") {
        return Ok(path::PathBuf::from(dir));
    }

    let fish_data_dir = load_fish_data_dir()?;
    Ok(fish_data_dir.join("pez"))
}

pub(crate) fn load_jobs() -> usize {
    if let Ok(val) = env::var("PEZ_JOBS")
        && let Ok(n) = val.parse::<usize>()
    {
        return n.max(1);
    }
    4
}

pub(crate) fn load_config() -> anyhow::Result<(config::Config, path::PathBuf)> {
    let config_path = load_pez_config_dir()?.join("pez.toml");

    let config = if config_path.exists() {
        config::load(&config_path)?
    } else {
        return Err(anyhow::anyhow!("Config file not found"));
    };

    Ok((config, config_path))
}

pub(crate) fn load_or_create_config() -> anyhow::Result<(config::Config, path::PathBuf)> {
    let config_dir = load_pez_config_dir()?;
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir)?;
    }
    let config_path = config_dir.join("pez.toml");
    let config = if config_path.exists() {
        config::load(&config_path)?
    } else {
        config::init()
    };

    Ok((config, config_path))
}

pub(crate) fn load_lock_file() -> anyhow::Result<(LockFile, path::PathBuf)> {
    let lock_file_dir = load_lock_file_dir()?;
    let lock_file_path = lock_file_dir.join("pez-lock.toml");
    let lock_file = if lock_file_path.exists() {
        lock_file::load(&lock_file_path)?
    } else {
        return Err(anyhow::anyhow!("Lock file not found"));
    };

    Ok((lock_file, lock_file_path))
}

pub(crate) fn load_or_create_lock_file() -> anyhow::Result<(LockFile, path::PathBuf)> {
    let lock_file_dir = load_lock_file_dir()?;
    if !lock_file_dir.exists() {
        fs::create_dir_all(&lock_file_dir)?;
    }
    let lock_file_path = lock_file_dir.join("pez-lock.toml");
    let lock_file = if lock_file_path.exists() {
        lock_file::load(&lock_file_path)?
    } else {
        lock_file::init()
    };

    Ok((lock_file, lock_file_path))
}

pub(crate) fn copy_plugin_files_from_repo(
    repo_path: &path::Path,
    plugin: &mut Plugin,
) -> anyhow::Result<()> {
    info!("{}Copying files:", Emoji("📂 ", ""));
    let fish_config_dir = load_fish_config_dir()?;
    let outcome = copy_plugin_files(repo_path, &fish_config_dir, plugin, None, false)?;
    let file_count = outcome.file_count;
    if file_count == 0 {
        warn_no_plugin_files();
    }
    Ok(())
}

#[derive(Debug, Default, Clone)]
pub(crate) struct CopyOutcome {
    pub file_count: usize,
    pub skipped_due_to_duplicate: bool,
}

pub(crate) fn copy_plugin_files(
    repo_path: &path::Path,
    fish_config_dir: &path::Path,
    plugin: &mut Plugin,
    mut dedupe: Option<&mut HashSet<path::PathBuf>>,
    skip_on_duplicate: bool,
) -> anyhow::Result<CopyOutcome> {
    let mut outcome = CopyOutcome::default();
    let target_dirs = TargetDir::all();
    let mut to_copy: Vec<(TargetDir, path::PathBuf)> = Vec::new();

    // Scan phase: gather files and check duplicates early
    for target_dir in &target_dirs {
        let target_path = repo_path.join(target_dir.as_str());
        if !target_path.exists() {
            continue;
        }
        let dest_dir = fish_config_dir.join(target_dir.as_str());
        if !dest_dir.exists() {
            fs::create_dir_all(&dest_dir)?;
        }

        let expected_ext = match target_dir {
            TargetDir::Themes => Some("theme"),
            _ => Some("fish"),
        };
        for entry in WalkDir::new(&target_path)
            .into_iter()
            .filter_map(Result::ok)
        {
            let entry_path = entry.path();
            if entry.file_type().is_dir() {
                continue;
            }
            if let Some(ext) = expected_ext
                && entry_path.extension().and_then(|s| s.to_str()) != Some(ext)
            {
                continue;
            }
            let rel = entry_path.strip_prefix(&target_path).with_context(|| {
                format!(
                    "Failed to strip prefix {} from {}",
                    target_path.display(),
                    entry_path.display()
                )
            })?;
            let dest_path = dest_dir.join(rel);
            if let Some(set) = dedupe.as_deref_mut()
                && set.contains(&dest_path)
                && skip_on_duplicate
            {
                warn!(
                    "{} Duplicate detected. Skipping plugin due to collision: {}",
                    Emoji("🚨 ", ""),
                    dest_path.display()
                );
                outcome.skipped_due_to_duplicate = true;
                return Ok(outcome);
            }
            to_copy.push((target_dir.clone(), rel.to_path_buf()));
        }
    }

    // Copy phase
    for (dir, rel) in to_copy.iter() {
        let src = repo_path.join(dir.as_str()).join(rel);
        let dest = fish_config_dir.join(dir.as_str()).join(rel);
        if let Some(parent) = dest.parent()
            && !parent.exists()
        {
            fs::create_dir_all(parent)?;
        }
        info!("   - {}", dest.display());
        fs::copy(&src, &dest)?;
        plugin.files.push(PluginFile {
            dir: dir.clone(),
            name: rel.to_string_lossy().to_string(),
        });
        outcome.file_count += 1;
        if let Some(set) = dedupe.as_deref_mut() {
            set.insert(dest);
        }
    }

    Ok(outcome)
}

#[allow(dead_code)]
fn copy_plugin_files_recursive(
    target_path: &path::Path,
    dest_path: &path::Path,
    target_dir: TargetDir,
    plugin: &mut Plugin,
) -> anyhow::Result<usize> {
    let mut file_count = 0;
    let expected_ext = match target_dir {
        TargetDir::Themes => Some("theme"),
        _ => Some("fish"),
    };

    for entry in WalkDir::new(target_path).into_iter().filter_map(Result::ok) {
        let entry_path = entry.path();
        if entry.file_type().is_dir() {
            continue;
        }
        if let Some(ext) = expected_ext
            && entry_path.extension().and_then(|s| s.to_str()) != Some(ext)
        {
            continue;
        }

        let rel = entry_path.strip_prefix(target_path).with_context(|| {
            format!(
                "Failed to strip prefix {} from {}",
                target_path.display(),
                entry_path.display()
            )
        })?;
        let dest_file_path = dest_path.join(rel);
        if let Some(parent) = dest_file_path.parent()
            && !parent.exists()
        {
            fs::create_dir_all(parent)?;
        }
        info!("   - {}", dest_file_path.display());
        fs::copy(entry_path, &dest_file_path)?;

        let plugin_file = PluginFile {
            dir: target_dir.clone(),
            name: rel.to_string_lossy().to_string(),
        };
        plugin.files.push(plugin_file);
        file_count += 1;
    }

    Ok(file_count)
}

pub(crate) enum Event {
    Install,
    Update,
    Uninstall,
}
impl fmt::Display for Event {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Event::Install => write!(f, "install"),
            Event::Update => write!(f, "update"),
            Event::Uninstall => write!(f, "uninstall"),
        }
    }
}

pub(crate) fn emit_event(file_name_or_path: &str, event: &Event) -> anyhow::Result<()> {
    let stem_opt = path::Path::new(file_name_or_path)
        .file_stem()
        .and_then(|s| s.to_str());
    match stem_opt {
        Some(stem) => {
            let output = std::process::Command::new("fish")
                .arg("-c")
                .arg(format!("emit {stem}_{event}"))
                .spawn()
                .context("Failed to spawn fish to emit event")?
                .wait_with_output()?;
            debug!("Emitted event: {}_{}", stem, event);

            if !output.status.success() {
                error!("Command executed with failing error code");
            }
        }
        None => {
            warn!(
                "Could not extract plugin name from file name: {}",
                file_name_or_path
            );
        }
    }

    Ok(())
}

fn warn_no_plugin_files() {
    warn!(
        "{} No valid files found in the repository.",
        console::style("Warning:").yellow()
    );
    warn!(
        "Ensure that it contains at least one file in 'functions', 'completions', 'conf.d', or 'themes'."
    );
}

#[cfg(test)]
mod tests {
    use config::{PluginSource, PluginSpec};

    use super::*;
    use crate::models::PluginRepo;
    use crate::models::TargetDir;
    use crate::tests_support::env::TestEnvironmentSetup;

    struct TestDataBuilder {
        plugin: Plugin,
        plugin_spec: PluginSpec,
    }

    impl TestDataBuilder {
        fn new() -> Self {
            Self {
                plugin: Plugin {
                    name: "repo".to_string(),
                    repo: PluginRepo {
                        owner: "owner".to_string(),
                        repo: "repo".to_string(),
                    },
                    source: "https://example.com/owner/repo".to_string(),
                    commit_sha: "sha".to_string(),
                    files: vec![],
                },
                plugin_spec: PluginSpec {
                    name: None,
                    source: PluginSource::Repo {
                        repo: PluginRepo {
                            owner: "owner".to_string(),
                            repo: "repo".to_string(),
                        },
                        version: None,
                        branch: None,
                        tag: None,
                        commit: None,
                    },
                },
            }
        }
        fn build(self) -> TestData {
            TestData {
                plugin: self.plugin,
                plugin_spec: self.plugin_spec,
            }
        }
    }

    struct TestData {
        plugin: Plugin,
        plugin_spec: PluginSpec,
    }

    #[test]
    fn test_copy_plugin_files() {
        let test_env = TestEnvironmentSetup::new();
        let mut test_data = TestDataBuilder::new().build();

        let plugin_files = vec![PluginFile {
            dir: TargetDir::Functions,
            name: "file.fish".to_string(),
        }];
        let repo = test_data.plugin_spec.get_plugin_repo().unwrap();
        fs::create_dir_all(test_env.data_dir.join(repo.as_str())).unwrap();
        test_env.add_plugin_files_to_repo(&repo, &plugin_files);

        let target_dir = TargetDir::Functions;
        let target_path = test_env
            .data_dir
            .join(repo.as_str())
            .join(target_dir.as_str());
        let dest_path = test_env.fish_config_dir.join(target_dir.as_str());
        fs::create_dir(&dest_path).unwrap();
        assert!(dest_path.exists());

        let repo_file_path = target_path.join(&plugin_files[0].name);
        assert!(fs::read(repo_file_path).is_ok());

        let files = fs::read_dir(&target_path).unwrap();
        assert_eq!(files.count(), plugin_files.len());

        let result = copy_plugin_files_recursive(
            &target_path,
            &dest_path,
            target_dir.clone(),
            &mut test_data.plugin,
        );
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), plugin_files.len());

        let copied_files: Vec<_> = test_env
            .fish_config_dir
            .join(target_dir.as_str())
            .read_dir()
            .unwrap()
            .collect();
        assert_eq!(copied_files.len(), plugin_files.len());

        copied_files.into_iter().for_each(|file| {
            let file = file.unwrap();
            assert_eq!(file.file_name().to_string_lossy(), plugin_files[0].name);
        });
    }

    #[test]
    fn test_copy_plugin_files_skips_non_file_entries() {
        let test_env = TestEnvironmentSetup::new();
        let mut test_data = TestDataBuilder::new().build();

        let repo = test_data.plugin_spec.get_plugin_repo().unwrap();
        let target_dir = TargetDir::Functions;

        let target_path = test_env
            .data_dir
            .join(repo.as_str())
            .join(target_dir.as_str());
        let dest_path = test_env.fish_config_dir.join(target_dir.as_str());
        fs::create_dir_all(&dest_path).unwrap();
        assert!(dest_path.exists());

        let not_func_dir = test_env
            .data_dir
            .join(repo.as_str())
            .join(target_dir.as_str())
            .join("dir");
        fs::create_dir_all(&not_func_dir).unwrap();
        assert!(fs::read(not_func_dir).is_err());

        let files = fs::read_dir(&target_path).unwrap();
        assert_eq!(files.count(), 1);

        let result = copy_plugin_files_recursive(
            &target_path,
            &dest_path,
            target_dir.clone(),
            &mut test_data.plugin,
        );
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);

        let copied_files: Vec<_> = test_env
            .fish_config_dir
            .join(target_dir.as_str())
            .read_dir()
            .unwrap()
            .collect();
        assert_eq!(copied_files.len(), 0);
    }

    #[test]
    fn test_copy_plugin_files_deep_directories() {
        let test_env = TestEnvironmentSetup::new();
        let mut test_data = TestDataBuilder::new().build();

        let plugin_files = vec![PluginFile {
            dir: TargetDir::Functions,
            name: "nested/dir/sample.fish".to_string(),
        }];

        let repo = test_data.plugin_spec.get_plugin_repo().unwrap();
        fs::create_dir_all(test_env.data_dir.join(repo.as_str())).unwrap();
        test_env.add_plugin_files_to_repo(&repo, &plugin_files);

        let target_dir = TargetDir::Functions;
        let target_path = test_env
            .data_dir
            .join(repo.as_str())
            .join(target_dir.as_str());
        let dest_path = test_env.fish_config_dir.join(target_dir.as_str());
        fs::create_dir_all(&dest_path).unwrap();

        let result = copy_plugin_files_recursive(
            &target_path,
            &dest_path,
            target_dir.clone(),
            &mut test_data.plugin,
        );
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1);

        assert!(
            dest_path.join("nested/dir/sample.fish").exists(),
            "Nested file should be copied to matching path"
        );

        assert!(
            test_data
                .plugin
                .files
                .iter()
                .any(|f| f.dir == TargetDir::Functions && f.name == "nested/dir/sample.fish")
        );
    }

    #[test]
    fn test_copy_plugin_files_dedupe_skip_on_duplicate() {
        let test_env = TestEnvironmentSetup::new();
        let mut test_data = TestDataBuilder::new().build();

        // Arrange: create a repo with one function file
        let plugin_files = vec![PluginFile {
            dir: TargetDir::Functions,
            name: "sample.fish".to_string(),
        }];
        let repo = test_data.plugin_spec.get_plugin_repo().unwrap();
        std::fs::create_dir_all(test_env.data_dir.join(repo.as_str())).unwrap();
        test_env.add_plugin_files_to_repo(&repo, &plugin_files);

        // Pre-create the destination path and mark it as already occupied in dedupe set
        let dest_dir = test_env.fish_config_dir.join(TargetDir::Functions.as_str());
        std::fs::create_dir_all(&dest_dir).unwrap();
        let existing_dest = dest_dir.join("sample.fish");
        std::fs::File::create(&existing_dest).unwrap();

        let mut dedupe = std::collections::HashSet::new();
        dedupe.insert(existing_dest.clone());

        // Act: copy with dedupe and skip_on_duplicate = true
        let repo_path = test_env.data_dir.join(repo.as_str());
        let outcome = copy_plugin_files(
            &repo_path,
            &test_env.fish_config_dir,
            &mut test_data.plugin,
            Some(&mut dedupe),
            true,
        )
        .expect("copy should not error");

        // Assert: skip flagged, no files recorded/copied beyond pre-existing
        assert!(outcome.skipped_due_to_duplicate);
        assert_eq!(outcome.file_count, 0);
        assert!(test_data.plugin.files.is_empty());
        // Pre-existing file remains
        assert!(std::fs::metadata(&existing_dest).is_ok());
    }
}
</file>

<file path="src/cli.rs">
use clap::{Args, Parser, Subcommand};
// keep derives in case of future clap value types
#[allow(unused_imports)]
use serde_derive::{Deserialize, Serialize};

#[derive(Parser, Debug)]
#[command(name = "pez", version, about, long_about = None)]
pub(crate) struct Cli {
    /// Increase output verbosity (-v for info, -vv for debug)
    #[arg(short, long, action = clap::ArgAction::Count)]
    pub(crate) verbose: u8,

    #[command(subcommand)]
    pub(crate) command: Commands,
}

#[derive(Subcommand, Debug)]
pub(crate) enum Commands {
    /// Initialize pez
    Init,

    /// Install fish plugin(s)
    Install(InstallArgs),

    /// Uninstall fish plugin(s)
    Uninstall(UninstallArgs),

    /// Upgrade installed fish plugin(s)
    Upgrade(UpgradeArgs),

    /// List installed fish plugins
    List(ListArgs),

    /// Prune uninstalled plugins
    Prune(PruneArgs),

    /// Generate shell completion scripts
    Completions {
        #[arg(value_enum)]
        shell: ShellType,
    },

    /// Diagnose common setup issues
    Doctor(DoctorArgs),

    /// Migrate from fisher (reads fish_plugins)
    Migrate(MigrateArgs),
}

#[derive(Args, Debug)]
pub(crate) struct InstallArgs {
    /// Plugin sources: `owner/repo[@ref]`, `host/owner/repo[@ref]`, full URL, or local path
    pub(crate) plugins: Option<Vec<crate::models::InstallTarget>>,

    /// Force install even if the plugin is already installed
    #[arg(short, long)]
    pub(crate) force: bool,

    /// Prune uninstalled plugins
    #[arg(short, long, conflicts_with = "plugins")]
    pub(crate) prune: bool,
}

#[derive(Args, Debug)]
pub(crate) struct UninstallArgs {
    /// GitHub repo in the format `owner/repo`
    pub(crate) plugins: Option<Vec<crate::models::PluginRepo>>,

    /// Force uninstall even if the plugin data directory does not exist
    #[arg(short, long)]
    pub(crate) force: bool,
}

#[derive(Args, Debug)]
pub(crate) struct UpgradeArgs {
    /// GitHub repo in the format `owner/repo`
    pub(crate) plugins: Option<Vec<crate::models::PluginRepo>>,
}

#[derive(Args, Debug)]
pub(crate) struct ListArgs {
    /// List format
    #[arg(long, value_enum)]
    pub(crate) format: Option<ListFormat>,

    /// Show only outdated plugins
    #[arg(long)]
    pub(crate) outdated: bool,
}

#[derive(Args, Debug)]
pub(crate) struct PruneArgs {
    /// Force prune even if the plugin data directory does not exist
    #[arg(short, long)]
    pub(crate) force: bool,

    /// Dry run without actually removing any files
    #[arg(long)]
    pub(crate) dry_run: bool,

    /// Confirm all prompts
    #[arg(short, long)]
    pub(crate) yes: bool,
}

#[derive(Debug, Clone, clap::ValueEnum)]
pub(crate) enum ListFormat {
    Plain,
    Table,
    Json,
}

#[derive(clap::ValueEnum, Clone, Debug)]
pub(crate) enum ShellType {
    Fish,
}

#[derive(Args, Debug)]
pub(crate) struct DoctorArgs {
    /// Output format
    #[arg(long, value_enum)]
    pub(crate) format: Option<DoctorFormat>,
}

#[derive(clap::ValueEnum, Clone, Debug)]
pub(crate) enum DoctorFormat {
    Json,
}

// Types moved to models.rs: PluginRepo, InstallTarget, ResolvedInstallTarget

use crate::models::{InstallTarget, PluginRepo, ResolvedInstallTarget};

impl InstallTarget {
    /// Create an InstallTarget from a raw string.
    pub fn from_raw<S: Into<String>>(s: S) -> Self {
        InstallTarget { raw: s.into() }
    }
    /// Parse the raw string into a `ResolvedInstallTarget`.
    /// Rules:
    /// - `owner/repo[@ref]` => github.com
    /// - `host/owner/repo[@ref]` (no scheme) => <https://host/owner/repo>
    /// - URLs with scheme left as-is (no `@ref` parsing to avoid ssh user@ conflicts)
    /// - Paths beginning with '/', './', '../', or '~' are treated as local
    pub fn resolve(&self) -> anyhow::Result<ResolvedInstallTarget> {
        use anyhow::Context;
        let raw = self.raw.trim();

        // Local path detection
        let looks_like_path = raw.starts_with('/')
            || raw.starts_with("./")
            || raw.starts_with("../")
            || raw.starts_with('~');

        // URL/scheme detection
        let has_scheme =
            raw.contains("://") || raw.starts_with("git@") || raw.starts_with("ssh://");

        // Helper to expand ~
        let expand_tilde = |p: &str| -> anyhow::Result<String> {
            if let Some(stripped) = p.strip_prefix("~/") {
                let home =
                    std::env::var_os("HOME").ok_or_else(|| anyhow::anyhow!("HOME not set"))?;
                Ok(std::path::Path::new(&home)
                    .join(stripped)
                    .to_string_lossy()
                    .to_string())
            } else if p == "~" {
                let home =
                    std::env::var_os("HOME").ok_or_else(|| anyhow::anyhow!("HOME not set"))?;
                Ok(std::path::PathBuf::from(home).to_string_lossy().to_string())
            } else {
                Ok(p.to_string())
            }
        };

        if looks_like_path {
            let mut path_str = expand_tilde(raw)?;
            // Normalize relative paths (./, ../, .) to absolute using current_dir
            if path_str == "." || path_str.starts_with("./") || path_str.starts_with("../") {
                let abs = std::env::current_dir()
                    .context("Failed to read current working directory")?
                    .join(&path_str);
                path_str = abs.to_string_lossy().to_string();
            }
            let plugin_name = std::path::Path::new(&path_str)
                .file_name()
                .and_then(|s| s.to_str())
                .ok_or_else(|| anyhow::anyhow!("Invalid local path: {path_str}"))?
                .to_string();
            let plugin_repo = PluginRepo {
                owner: "local".to_string(),
                repo: plugin_name,
            };
            return Ok(ResolvedInstallTarget {
                plugin_repo,
                source: path_str,
                ref_kind: crate::resolver::RefKind::None,
                is_local: true,
            });
        }

        // Full URL (leave as-is; no @ref parsing to avoid ssh user@host conflict)
        if has_scheme {
            let url = raw.to_string();
            // Try to infer owner/repo from path for naming, else fallback to last segment
            let repo_name = url
                .rsplit('/')
                .next()
                .map(|s| s.trim_end_matches(".git"))
                .unwrap_or("repo")
                .to_string();
            let plugin_repo = PluginRepo {
                owner: "url".to_string(),
                repo: repo_name,
            };
            return Ok(ResolvedInstallTarget {
                plugin_repo,
                source: url,
                ref_kind: crate::resolver::RefKind::None,
                is_local: false,
            });
        }

        // host/owner/repo[@ref] or owner/repo[@ref]
        let (base, ref_kind) = match raw.split_once('@') {
            Some((lhs, rhs)) => (lhs.to_string(), crate::resolver::parse_ref_kind(rhs)),
            None => (raw.to_string(), crate::resolver::RefKind::None),
        };

        let parts: Vec<&str> = base.split('/').collect();
        if parts.len() == 2 {
            // owner/repo -> default host github.com
            let owner = parts[0].to_string();
            let repo = parts[1].to_string();
            let plugin_repo = PluginRepo { owner, repo };
            let source = format!("https://github.com/{}", plugin_repo.as_str());
            return Ok(ResolvedInstallTarget {
                plugin_repo,
                source,
                ref_kind,
                is_local: false,
            });
        } else if parts.len() == 3 {
            // host/owner/repo -> https host
            let host = parts[0];
            let owner = parts[1].to_string();
            let repo = parts[2].to_string();
            let plugin_repo = PluginRepo { owner, repo };
            let source = format!("https://{host}/{}", plugin_repo.as_str());
            return Ok(ResolvedInstallTarget {
                plugin_repo,
                source,
                ref_kind,
                is_local: false,
            });
        }

        Err(anyhow::anyhow!(format!(
            "Invalid plugin source: {raw}. Expected <owner>/<repo>[@ref], <host>/<owner>/<repo>[@ref], URL, or local path"
        )))
            .context("Failed to parse install target")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn resolve_owner_repo_and_variants() {
        // owner/repo (github)
        let t: InstallTarget = "o/r".parse().unwrap();
        let r = t.resolve().unwrap();
        assert_eq!(r.plugin_repo.as_str(), "o/r");
        assert_eq!(r.source, "https://github.com/o/r");
        assert!(!r.is_local);

        // owner/repo@v3 -> Version
        let t: InstallTarget = "o/r@v3".parse().unwrap();
        let r = t.resolve().unwrap();
        matches!(r.ref_kind, crate::resolver::RefKind::Version(_));

        // explicit tag/branch/commit
        let t: InstallTarget = "o/r@tag:v1.0.0".parse().unwrap();
        let r = t.resolve().unwrap();
        matches!(r.ref_kind, crate::resolver::RefKind::Tag(_));

        let t: InstallTarget = "gitlab.com/o/r@branch:dev".parse().unwrap();
        let r = t.resolve().unwrap();
        assert_eq!(r.source, "https://gitlab.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::Branch(_));

        let t: InstallTarget = "https://example.com/o/r".parse().unwrap();
        let r = t.resolve().unwrap();
        assert_eq!(r.source, "https://example.com/o/r");
        matches!(r.ref_kind, crate::resolver::RefKind::None);

        // local path
        let home = std::env::var("HOME").unwrap();
        let t = InstallTarget::from_raw(home.to_string());
        let r = t.resolve().unwrap();
        assert!(r.is_local);

        // relative path should be normalized to absolute
        let t = InstallTarget::from_raw("./some/dir");
        let r = t.resolve().unwrap();
        assert!(r.is_local);
        let cwd = std::env::current_dir().unwrap();
        assert!(r.source.starts_with(&*cwd.to_string_lossy()));
    }
}

#[derive(Args, Debug)]
pub(crate) struct MigrateArgs {
    /// Do not write files; print planned changes
    #[arg(long)]
    pub(crate) dry_run: bool,

    /// Overwrite existing pez.toml plugin list instead of merging
    #[arg(long)]
    pub(crate) force: bool,

    /// Immediately install migrated plugins
    #[arg(long)]
    pub(crate) install: bool,
}
</file>

<file path="Cargo.toml">
[package]
name = "pez"
version = "0.1.3"
edition = "2024"
description = "A Rust-based plugin manager for fish."
readme = "README.md"
repository = "https://github.com/tetzng/pez"
license = "MIT"
keywords = ["fish", "plugin", "manager"]
categories = ["command-line-utilities"]

[dependencies]
clap = { version = "4.5.47", features = ["derive"] }
console = "0.16.1"
git2 = "0.20.2"
serde = "1.0.219"
serde_derive = "1.0.216"
sha2 = "0.10.9"
tabled = "0.20.0"
toml = "0.9.5"
clap_complete = "4.5.57"
regex = "1.11.2"
futures = "0.3.31"
tokio = { version = "1.47.1", features = ["macros", "rt", "rt-multi-thread", "sync"] }
anyhow = "1.0.99"
tempfile = "3.22.0"
tracing = "0.1.41"
tracing-subscriber = { version = "0.3.20", features = ["env-filter"] }
serde_json = "1.0.143"
walkdir = "2.5.0"
semver = "1.0.23"
</file>

</files>
