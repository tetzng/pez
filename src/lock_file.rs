use crate::{models::PluginRepo, models::TargetDir};

use anyhow::anyhow;
use serde_derive::{Deserialize, Serialize};
use std::{fs, path};
use tracing::error;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct LockFile {
    pub(crate) version: u32,
    pub(crate) plugins: Vec<Plugin>,
}

pub(crate) fn init() -> LockFile {
    LockFile {
        version: 1,
        plugins: vec![],
    }
}

pub(crate) fn load(path: &path::Path) -> anyhow::Result<LockFile> {
    let content = fs::read_to_string(path)?;
    let lock_file = toml::from_str(&content)?;

    Ok(lock_file)
}

impl LockFile {
    pub(crate) fn save(&self, path: &path::Path) -> anyhow::Result<()> {
        let contents = toml::to_string(self)?;
        fs::write(path, AUTO_GENERATED_COMMENT.to_string() + &contents)?;

        Ok(())
    }

    pub(crate) fn add_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self
            .plugins
            .iter()
            .any(|p| p.source == plugin.source || p.name == plugin.name)
        {
            error!(
                "Plugin already exists: name={}, source={}",
                plugin.name, plugin.source
            );
            anyhow::bail!(
                "Plugin already exists: name={}, source={}",
                plugin.name,
                plugin.source
            );
        }
        self.plugins.push(plugin);
        Ok(())
    }

    pub(crate) fn remove_plugin(&mut self, source: &str) {
        self.plugins.retain(|p| p.source != source);
    }

    pub(crate) fn get_plugin_by_repo(&self, repo: &PluginRepo) -> Option<&Plugin> {
        self.plugins.iter().find(|p| &p.repo == repo)
    }

    pub(crate) fn update_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        self.remove_plugin(&plugin.source);
        self.add_plugin(plugin)?;
        Ok(())
    }

    pub(crate) fn merge_plugins(&mut self, new_plugins: Vec<Plugin>) {
        for new_plugin in new_plugins {
            let source = new_plugin.source.clone();
            if let Some(plugin) = self.plugins.iter_mut().find(|p| p.source == source) {
                *plugin = new_plugin;
            } else {
                self.plugins.push(new_plugin);
            }
        }
    }

    /// Returns true if a plugin with the given repo exists.
    pub(crate) fn contains_repo(&self, repo: &PluginRepo) -> bool {
        self.plugins.iter().any(|p| &p.repo == repo)
    }

    /// Upsert a plugin by repo (or source) semantics. If repo exists, update; otherwise add.
    pub(crate) fn upsert_plugin_by_repo(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self.contains_repo(&plugin.repo) {
            self.update_plugin(plugin)
        } else {
            self.add_plugin(plugin)
        }
    }

    pub(crate) fn paths_for_repos(
        &self,
        repos: &[PluginRepo],
        config_dir: &path::Path,
        dir_filter: Option<&TargetDir>,
    ) -> anyhow::Result<Vec<path::PathBuf>> {
        let mut out = Vec::new();
        for repo in repos {
            let plugin = self
                .get_plugin_by_repo(repo)
                .ok_or_else(|| anyhow!("Plugin is not installed: {}", repo.as_str()))?;
            out.extend(plugin.resolve_paths(config_dir, dir_filter));
        }
        Ok(out)
    }
}

pub(crate) const AUTO_GENERATED_COMMENT: &str =
    "# This file is automatically generated by pez. Do not edit it manually.\n";

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct Plugin {
    pub(crate) name: String,
    pub(crate) repo: PluginRepo,
    pub(crate) source: String,
    pub(crate) commit_sha: String,
    pub(crate) files: Vec<PluginFile>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub(crate) struct PluginFile {
    pub(crate) dir: TargetDir,
    pub(crate) name: String,
}

impl Plugin {
    pub(crate) fn get_name(&self) -> String {
        if self.name.is_empty() {
            let parts: Vec<&str> = self.source.split("/").collect();
            parts[parts.len() - 1].to_owned()
        } else {
            self.name.clone()
        }
    }

    pub(crate) fn resolve_paths(
        &self,
        config_dir: &path::Path,
        dir_filter: Option<&TargetDir>,
    ) -> Vec<path::PathBuf> {
        self.files
            .iter()
            .filter(|f| dir_filter.is_none_or(|d| &f.dir == d))
            .map(|f| f.get_path(config_dir))
            .collect()
    }
}

impl PluginFile {
    pub(crate) fn get_path(&self, config_dir: &path::Path) -> path::PathBuf {
        config_dir.join(self.dir.as_str()).join(&self.name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn plugin_repo(owner: &str, repo: &str) -> PluginRepo {
        PluginRepo::new(None, owner.to_string(), repo.to_string()).expect("valid repo")
    }

    fn plugin_with(source: &str, name: &str) -> Plugin {
        Plugin {
            name: name.to_string(),
            repo: plugin_repo("owner", "repo"),
            source: source.to_string(),
            commit_sha: "deadbeef".to_string(),
            files: vec![],
        }
    }

    #[test]
    fn add_plugin_rejects_duplicate_source() {
        let mut lock = init();
        lock.add_plugin(plugin_with("https://example.com/owner/repo", "alpha"))
            .expect("add initial plugin");

        let err = lock
            .add_plugin(plugin_with("https://example.com/owner/repo", "beta"))
            .expect_err("expected duplicate source error");
        assert!(
            err.to_string().contains("Plugin already exists"),
            "unexpected error: {err}"
        );
    }

    #[test]
    fn add_plugin_rejects_duplicate_name() {
        let mut lock = init();
        lock.add_plugin(plugin_with("https://example.com/owner/repo", "alpha"))
            .expect("add initial plugin");

        let err = lock
            .add_plugin(plugin_with("https://example.com/owner/other", "alpha"))
            .expect_err("expected duplicate name error");
        assert!(
            err.to_string().contains("Plugin already exists"),
            "unexpected error: {err}"
        );
    }

    #[test]
    fn merge_plugins_updates_existing_and_adds_new() {
        let mut lock = LockFile {
            version: 1,
            plugins: vec![
                Plugin {
                    name: "alpha".to_string(),
                    repo: plugin_repo("owner", "alpha"),
                    source: "https://example.com/owner/alpha".to_string(),
                    commit_sha: "old".to_string(),
                    files: vec![],
                },
                Plugin {
                    name: "beta".to_string(),
                    repo: plugin_repo("owner", "beta"),
                    source: "https://example.com/owner/beta".to_string(),
                    commit_sha: "stable".to_string(),
                    files: vec![],
                },
            ],
        };

        let updated_alpha = Plugin {
            name: "alpha".to_string(),
            repo: plugin_repo("owner", "alpha"),
            source: "https://example.com/owner/alpha".to_string(),
            commit_sha: "new".to_string(),
            files: vec![],
        };
        let new_plugin = Plugin {
            name: "gamma".to_string(),
            repo: plugin_repo("owner", "gamma"),
            source: "https://example.com/owner/gamma".to_string(),
            commit_sha: "fresh".to_string(),
            files: vec![],
        };

        lock.merge_plugins(vec![updated_alpha.clone(), new_plugin.clone()]);

        let alpha = lock
            .plugins
            .iter()
            .find(|p| p.source == updated_alpha.source)
            .expect("alpha present");
        assert_eq!(alpha.commit_sha, "new");

        let beta = lock
            .plugins
            .iter()
            .find(|p| p.source == "https://example.com/owner/beta")
            .expect("beta present");
        assert_eq!(beta.commit_sha, "stable");

        let gamma = lock
            .plugins
            .iter()
            .find(|p| p.source == new_plugin.source)
            .expect("gamma present");
        assert_eq!(gamma.commit_sha, "fresh");
    }

    #[test]
    fn contains_repo_returns_false_for_missing_repo() {
        let lock = LockFile {
            version: 1,
            plugins: vec![Plugin {
                name: "alpha".to_string(),
                repo: plugin_repo("owner", "alpha"),
                source: "https://example.com/owner/alpha".to_string(),
                commit_sha: "deadbeef".to_string(),
                files: vec![],
            }],
        };

        let missing = plugin_repo("owner", "missing");
        assert!(!lock.contains_repo(&missing));
    }

    #[test]
    fn plugin_get_name_prefers_explicit_name_or_last_path_segment() {
        let named = Plugin {
            name: "custom".to_string(),
            repo: plugin_repo("owner", "repo"),
            source: "https://example.com/owner/repo".to_string(),
            commit_sha: "deadbeef".to_string(),
            files: vec![],
        };
        assert_eq!(named.get_name(), "custom");

        let unnamed = Plugin {
            name: "".to_string(),
            repo: plugin_repo("owner", "repo"),
            source: "https://example.com/owner/repo".to_string(),
            commit_sha: "deadbeef".to_string(),
            files: vec![],
        };
        assert_eq!(unnamed.get_name(), "repo");
    }
}
