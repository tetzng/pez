use crate::{cli::PluginRepo, models::TargetDir};

use serde_derive::{Deserialize, Serialize};
use std::{fs, path};
use tracing::error;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct LockFile {
    pub(crate) version: u32,
    pub(crate) plugins: Vec<Plugin>,
}

pub(crate) fn init() -> LockFile {
    LockFile {
        version: 1,
        plugins: vec![],
    }
}

pub(crate) fn load(path: &path::Path) -> anyhow::Result<LockFile> {
    let content = fs::read_to_string(path)?;
    let lock_file = toml::from_str(&content)?;

    Ok(lock_file)
}

impl LockFile {
    pub(crate) fn save(&self, path: &path::Path) -> anyhow::Result<()> {
        let contents = toml::to_string(self)?;
        fs::write(path, AUTO_GENERATED_COMMENT.to_string() + &contents)?;

        Ok(())
    }

    pub(crate) fn add_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self
            .plugins
            .iter()
            .any(|p| p.source == plugin.source || p.name == plugin.name)
        {
            error!(
                "Plugin already exists: name={}, source={}",
                plugin.name, plugin.source
            );
            anyhow::bail!(
                "Plugin already exists: name={}, source={}",
                plugin.name,
                plugin.source
            );
        }
        self.plugins.push(plugin);
        Ok(())
    }

    pub(crate) fn remove_plugin(&mut self, source: &str) {
        self.plugins.retain(|p| p.source != source);
    }

    pub(crate) fn get_plugin_by_repo(&self, repo: &PluginRepo) -> Option<&Plugin> {
        self.plugins.iter().find(|p| &p.repo == repo)
    }

    pub(crate) fn update_plugin(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        self.remove_plugin(&plugin.source);
        self.add_plugin(plugin)?;
        Ok(())
    }

    pub(crate) fn merge_plugins(&mut self, new_plugins: Vec<Plugin>) {
        for new_plugin in new_plugins {
            let source = new_plugin.source.clone();
            if let Some(plugin) = self.plugins.iter_mut().find(|p| p.source == source) {
                *plugin = new_plugin;
            } else {
                self.plugins.push(new_plugin);
            }
        }
    }

    /// Returns true if a plugin with the given repo exists.
    pub(crate) fn contains_repo(&self, repo: &PluginRepo) -> bool {
        self.plugins.iter().any(|p| &p.repo == repo)
    }

    /// Upsert a plugin by repo (or source) semantics. If repo exists, update; otherwise add.
    pub(crate) fn upsert_plugin_by_repo(&mut self, plugin: Plugin) -> anyhow::Result<()> {
        if self.contains_repo(&plugin.repo) {
            self.update_plugin(plugin)
        } else {
            self.add_plugin(plugin)
        }
    }
}

pub(crate) const AUTO_GENERATED_COMMENT: &str =
    "# This file is automatically generated by pez. Do not edit it manually.\n";

#[derive(Serialize, Deserialize, Debug, Clone)]
pub(crate) struct Plugin {
    pub(crate) name: String,
    pub(crate) repo: PluginRepo,
    pub(crate) source: String,
    pub(crate) commit_sha: String,
    pub(crate) files: Vec<PluginFile>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub(crate) struct PluginFile {
    pub(crate) dir: TargetDir,
    pub(crate) name: String,
}

impl Plugin {
    pub(crate) fn get_name(&self) -> String {
        if self.name.is_empty() {
            let parts: Vec<&str> = self.source.split("/").collect();
            parts[parts.len() - 1].to_owned()
        } else {
            self.name.clone()
        }
    }
}

impl PluginFile {
    pub(crate) fn get_path(&self, config_dir: &path::Path) -> path::PathBuf {
        config_dir.join(self.dir.as_str()).join(&self.name)
    }
}
